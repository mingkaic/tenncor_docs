<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tenncor: layr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tenncor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">layr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_conv.html">Conv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer implementation to apply conv2d functions to weight and optional bias.  <a href="structlayr_1_1_conv.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_conv_builder.html">ConvBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder implementation for convolution layer.  <a href="structlayr_1_1_conv_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_dense.html">Dense</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer implementation to apply fully_connect functions to weight and optional bias.  <a href="structlayr_1_1_dense.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_dense_builder.html">DenseBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder implementation for fully connected layer.  <a href="structlayr_1_1_dense_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1i_layer.html">iLayer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1i_layer_builder.html">iLayerBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_layer_id.html">LayerId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sublayer type, label, and index encapsulation.  <a href="structlayr_1_1_layer_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_layer_tag.html">LayerTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag implementation specifically for contents of layers.  <a href="structlayr_1_1_layer_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_r_b_m.html">RBM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_r_b_m_builder.html">RBMBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder implementation for restricted boltzmann layer.  <a href="structlayr_1_1_r_b_m_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_seq_model_builder.html">SeqModelBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder implementation for sequentially connected models.  <a href="structlayr_1_1_seq_model_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_sequential_model.html">SequentialModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer implementation that sequentially applies sublayers.  <a href="structlayr_1_1_sequential_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_u_layer.html">ULayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer implementation to apply activation and pooling functions.  <a href="structlayr_1_1_u_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_u_layer_builder.html">ULayerBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder implementation for activation layer.  <a href="structlayr_1_1_u_layer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlayr_1_1_var_assign.html">VarAssign</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable and error approximation assignment encapsulation.  <a href="structlayr_1_1_var_assign.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a37a651019f5790e7f92a4a5f2db5df52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a37a651019f5790e7f92a4a5f2db5df52">ConvptrT</a> = std::shared_ptr&lt; <a class="el" href="structlayr_1_1_conv.html">Conv</a> &gt;</td></tr>
<tr class="memdesc:a37a651019f5790e7f92a4a5f2db5df52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of convolutional layer.  <a href="#a37a651019f5790e7f92a4a5f2db5df52">More...</a><br /></td></tr>
<tr class="separator:a37a651019f5790e7f92a4a5f2db5df52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06ffe9ce80e1d23a39f79c4dc7cc4c9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#ae06ffe9ce80e1d23a39f79c4dc7cc4c9">DenseptrT</a> = std::shared_ptr&lt; <a class="el" href="structlayr_1_1_dense.html">Dense</a> &gt;</td></tr>
<tr class="memdesc:ae06ffe9ce80e1d23a39f79c4dc7cc4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of fully connected layer.  <a href="#ae06ffe9ce80e1d23a39f79c4dc7cc4c9">More...</a><br /></td></tr>
<tr class="separator:ae06ffe9ce80e1d23a39f79c4dc7cc4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9f6661ecd0f52f8a3507ff0c238842"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#afa9f6661ecd0f52f8a3507ff0c238842">VarErrsT</a> = std::vector&lt; std::pair&lt; <a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">eteq::VarptrT</a>&lt; PybindT &gt;, NodeptrT &gt; &gt;</td></tr>
<tr class="memdesc:afa9f6661ecd0f52f8a3507ff0c238842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered association between variable and error.  <a href="#afa9f6661ecd0f52f8a3507ff0c238842">More...</a><br /></td></tr>
<tr class="separator:afa9f6661ecd0f52f8a3507ff0c238842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa44ed30c9507630e97563964b1b2e5d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#aaa44ed30c9507630e97563964b1b2e5d">AssignsT</a> = std::vector&lt; <a class="el" href="structlayr_1_1_var_assign.html">VarAssign</a> &gt;</td></tr>
<tr class="memdesc:aaa44ed30c9507630e97563964b1b2e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">One batch of assignments.  <a href="#aaa44ed30c9507630e97563964b1b2e5d">More...</a><br /></td></tr>
<tr class="separator:aaa44ed30c9507630e97563964b1b2e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd616a9b8451b1ac5f451f1589f7983"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a> = std::vector&lt; <a class="el" href="namespacelayr.html#aaa44ed30c9507630e97563964b1b2e5d">AssignsT</a> &gt;</td></tr>
<tr class="memdesc:a5fd616a9b8451b1ac5f451f1589f7983"><td class="mdescLeft">&#160;</td><td class="mdescRight">All batches of assignments.  <a href="#a5fd616a9b8451b1ac5f451f1589f7983">More...</a><br /></td></tr>
<tr class="separator:a5fd616a9b8451b1ac5f451f1589f7983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ea27d659d3cee1503e52d07c942d0e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a83ea27d659d3cee1503e52d07c942d0e">ApproxF</a> = std::function&lt; <a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a>(const <a class="el" href="namespacelayr.html#afa9f6661ecd0f52f8a3507ff0c238842">VarErrsT</a> &amp;)&gt;</td></tr>
<tr class="separator:a83ea27d659d3cee1503e52d07c942d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cfcd30444af970454ad839af3eee85"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a63cfcd30444af970454ad839af3eee85">UpdateStepF</a> = std::function&lt; void(<a class="el" href="namespaceteq.html#a06d5cc6ba08f690e19ee8cf46d289993">teq::TensSetT</a> &amp;)&gt;</td></tr>
<tr class="separator:a63cfcd30444af970454ad839af3eee85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d4e642c6e804bca85f0ea1b7bae15b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8d4e642c6e804bca85f0ea1b7bae15b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a> = std::function&lt; <a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">eteq::VarptrT</a>&lt; T &gt;(<a class="el" href="structteq_1_1_shape.html">teq::Shape</a>, std::string)&gt;</td></tr>
<tr class="memdesc:aa8d4e642c6e804bca85f0ea1b7bae15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that produces a variable given the variable's shape and label.  <a href="#aa8d4e642c6e804bca85f0ea1b7bae15b">More...</a><br /></td></tr>
<tr class="separator:aa8d4e642c6e804bca85f0ea1b7bae15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa34b531ef5803cd9a5242ff031d7b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaa34b531ef5803cd9a5242ff031d7b9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#adaa34b531ef5803cd9a5242ff031d7b9">ShapeFactorF</a> = std::function&lt; T(<a class="el" href="structteq_1_1_shape.html">teq::Shape</a>)&gt;</td></tr>
<tr class="memdesc:adaa34b531ef5803cd9a5242ff031d7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns some metric of a shape.  <a href="#adaa34b531ef5803cd9a5242ff031d7b9">More...</a><br /></td></tr>
<tr class="separator:adaa34b531ef5803cd9a5242ff031d7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2999f55c6588e8e62c63f21cfd9581fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a2999f55c6588e8e62c63f21cfd9581fc">LayerIdsT</a> = std::vector&lt; <a class="el" href="structlayr_1_1_layer_id.html">LayerId</a> &gt;</td></tr>
<tr class="memdesc:a2999f55c6588e8e62c63f21cfd9581fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of sublayer ids.  <a href="#a2999f55c6588e8e62c63f21cfd9581fc">More...</a><br /></td></tr>
<tr class="separator:a2999f55c6588e8e62c63f21cfd9581fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafbe478fabdc9c0482dd4bb5759f285"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#afafbe478fabdc9c0482dd4bb5759f285">LayerptrT</a> = std::shared_ptr&lt; <a class="el" href="structlayr_1_1i_layer.html">iLayer</a> &gt;</td></tr>
<tr class="memdesc:afafbe478fabdc9c0482dd4bb5759f285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of layer.  <a href="#afafbe478fabdc9c0482dd4bb5759f285">More...</a><br /></td></tr>
<tr class="separator:afafbe478fabdc9c0482dd4bb5759f285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbe8de1349b0415b6d24f5377522b28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a> = std::shared_ptr&lt; <a class="el" href="structlayr_1_1i_layer_builder.html">iLayerBuilder</a> &gt;</td></tr>
<tr class="memdesc:acbbe8de1349b0415b6d24f5377522b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer builder smart pointer.  <a href="#acbbe8de1349b0415b6d24f5377522b28">More...</a><br /></td></tr>
<tr class="separator:acbbe8de1349b0415b6d24f5377522b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0df474a71266252c2652402471fff99"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#af0df474a71266252c2652402471fff99">LayerBuildF</a> = std::function&lt; <a class="el" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a>(std::string)&gt;</td></tr>
<tr class="memdesc:af0df474a71266252c2652402471fff99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that takes layer type and returns associated layer builder.  <a href="#af0df474a71266252c2652402471fff99">More...</a><br /></td></tr>
<tr class="separator:af0df474a71266252c2652402471fff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e187a48b5bebf9f04e7f95ce560cb69"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a4e187a48b5bebf9f04e7f95ce560cb69">RBMptrT</a> = std::shared_ptr&lt; <a class="el" href="structlayr_1_1_r_b_m.html">RBM</a> &gt;</td></tr>
<tr class="memdesc:a4e187a48b5bebf9f04e7f95ce560cb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of <a class="el" href="structlayr_1_1_r_b_m.html">RBM</a> layer.  <a href="#a4e187a48b5bebf9f04e7f95ce560cb69">More...</a><br /></td></tr>
<tr class="separator:a4e187a48b5bebf9f04e7f95ce560cb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71287ab7fdb69f470d1cb6b672a681da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a71287ab7fdb69f470d1cb6b672a681da">SeqModelptrT</a> = std::shared_ptr&lt; <a class="el" href="structlayr_1_1_sequential_model.html">SequentialModel</a> &gt;</td></tr>
<tr class="memdesc:a71287ab7fdb69f470d1cb6b672a681da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of sequentially connected model.  <a href="#a71287ab7fdb69f470d1cb6b672a681da">More...</a><br /></td></tr>
<tr class="separator:a71287ab7fdb69f470d1cb6b672a681da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1df0c3b4774d80511748e06f4dfd9f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#aad1df0c3b4774d80511748e06f4dfd9f">UnaryF</a> = std::function&lt; NodeptrT(const <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a> &amp;, NodeptrT)&gt;</td></tr>
<tr class="memdesc:aad1df0c3b4774d80511748e06f4dfd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that takes corresponding unary layer and node.  <a href="#aad1df0c3b4774d80511748e06f4dfd9f">More...</a><br /></td></tr>
<tr class="separator:aad1df0c3b4774d80511748e06f4dfd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd75d90f3b421949f491559fcfe49be9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a> = std::shared_ptr&lt; <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a> &gt;</td></tr>
<tr class="memdesc:acd75d90f3b421949f491559fcfe49be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of unary layer.  <a href="#acd75d90f3b421949f491559fcfe49be9">More...</a><br /></td></tr>
<tr class="separator:acd75d90f3b421949f491559fcfe49be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9e8d161ff4a643d41292f56938a29a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a9e8d161ff4a643d41292f56938a29a82">sgd</a> (const <a class="el" href="namespacelayr.html#afa9f6661ecd0f52f8a3507ff0c238842">VarErrsT</a> &amp;leaves, PybindT learning_rate=0.5, std::string root_label=&quot;&quot;)</td></tr>
<tr class="separator:a9e8d161ff4a643d41292f56938a29a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87e6083795256c7676a3464a1f1b6a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#ac87e6083795256c7676a3464a1f1b6a5">rms_momentum</a> (const <a class="el" href="namespacelayr.html#afa9f6661ecd0f52f8a3507ff0c238842">VarErrsT</a> &amp;leaves, PybindT learning_rate=0.5, PybindT discount_factor=0.99, PybindT epsilon=std::numeric_limits&lt; PybindT &gt;::epsilon(), std::string root_label=&quot;&quot;)</td></tr>
<tr class="separator:ac87e6083795256c7676a3464a1f1b6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41fa39bdd87ddcf75ca3f44ebafe6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a5c41fa39bdd87ddcf75ca3f44ebafe6e">assign_groups</a> (const <a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a> &amp;groups, <a class="el" href="namespacelayr.html#a63cfcd30444af970454ad839af3eee85">UpdateStepF</a> update_step)</td></tr>
<tr class="memdesc:a5c41fa39bdd87ddcf75ca3f44ebafe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply all batches of assignments with update_step applied after each batch.  <a href="#a5c41fa39bdd87ddcf75ca3f44ebafe6e">More...</a><br /></td></tr>
<tr class="separator:a5c41fa39bdd87ddcf75ca3f44ebafe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47031f1ccfaef5e2b7e69e90b47d786c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a47031f1ccfaef5e2b7e69e90b47d786c">assign_groups_preupdate</a> (const <a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a> &amp;groups, <a class="el" href="namespacelayr.html#a63cfcd30444af970454ad839af3eee85">UpdateStepF</a> update_step)</td></tr>
<tr class="memdesc:a47031f1ccfaef5e2b7e69e90b47d786c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply all batches of assignments with update_step applied before each batch.  <a href="#a47031f1ccfaef5e2b7e69e90b47d786c">More...</a><br /></td></tr>
<tr class="separator:a47031f1ccfaef5e2b7e69e90b47d786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f584c9d897ad1f661dc9eb570f4407f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f584c9d897ad1f661dc9eb570f4407f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a6f584c9d897ad1f661dc9eb570f4407f">fanio</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape)</td></tr>
<tr class="memdesc:a6f584c9d897ad1f661dc9eb570f4407f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the first 2 dimensions of a shape.  <a href="#a6f584c9d897ad1f661dc9eb570f4407f">More...</a><br /></td></tr>
<tr class="separator:a6f584c9d897ad1f661dc9eb570f4407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925fffac0436c9a8659ba847741d1283"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a925fffac0436c9a8659ba847741d1283"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a925fffac0436c9a8659ba847741d1283">fanavg</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape)</td></tr>
<tr class="memdesc:a925fffac0436c9a8659ba847741d1283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mean of the first 2 dimensions of a shape.  <a href="#a925fffac0436c9a8659ba847741d1283">More...</a><br /></td></tr>
<tr class="separator:a925fffac0436c9a8659ba847741d1283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d021587dfe7fd257e43d2137960158"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93d021587dfe7fd257e43d2137960158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a93d021587dfe7fd257e43d2137960158">truncated_normal</a> (std::vector&lt; T &gt; &amp;out, <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape, T mean, T stdev, size_t max_repick=5)</td></tr>
<tr class="separator:a93d021587dfe7fd257e43d2137960158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadef664ac3354e08fcf2170933d702f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acadef664ac3354e08fcf2170933d702f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#acadef664ac3354e08fcf2170933d702f">zero_init</a> (void)</td></tr>
<tr class="memdesc:acadef664ac3354e08fcf2170933d702f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return initialization function that makes zero variables.  <a href="#acadef664ac3354e08fcf2170933d702f">More...</a><br /></td></tr>
<tr class="separator:acadef664ac3354e08fcf2170933d702f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7378022d7e5649b3d8d56505744f51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd7378022d7e5649b3d8d56505744f51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#afd7378022d7e5649b3d8d56505744f51">variance_scaling_init</a> (T factor, <a class="el" href="namespacelayr.html#adaa34b531ef5803cd9a5242ff031d7b9">ShapeFactorF</a>&lt; T &gt; sfactor=<a class="el" href="namespacelayr.html#a925fffac0436c9a8659ba847741d1283">fanavg</a>&lt; T &gt;)</td></tr>
<tr class="separator:afd7378022d7e5649b3d8d56505744f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc309fed2a58080955d89ee20361a8d4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc309fed2a58080955d89ee20361a8d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#adc309fed2a58080955d89ee20361a8d4">unif_xavier_init</a> (T factor=1)</td></tr>
<tr class="separator:adc309fed2a58080955d89ee20361a8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ca48af51216db64440ffc509150ddb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01ca48af51216db64440ffc509150ddb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a01ca48af51216db64440ffc509150ddb">norm_xavier_init</a> (T factor=1)</td></tr>
<tr class="separator:a01ca48af51216db64440ffc509150ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad082dc95f94d4dee08a6db2703fb13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a7ad082dc95f94d4dee08a6db2703fb13">validate_label</a> (const std::string &amp;label)</td></tr>
<tr class="separator:a7ad082dc95f94d4dee08a6db2703fb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4358db53a9feefdd2150425d1849b01"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#ab4358db53a9feefdd2150425d1849b01">layer_label_fmt</a> (std::string label, <a class="el" href="structlayr_1_1_layer_id.html">LayerId</a> subid)</td></tr>
<tr class="memdesc:ab4358db53a9feefdd2150425d1849b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return formatted raw label with associated sublayer.  <a href="#ab4358db53a9feefdd2150425d1849b01">More...</a><br /></td></tr>
<tr class="separator:ab4358db53a9feefdd2150425d1849b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aeb65b506bec147f76ec3efe49f9ef"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="namespacelayr.html#a2999f55c6588e8e62c63f21cfd9581fc">LayerIdsT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a28aeb65b506bec147f76ec3efe49f9ef">unpack_labels</a> (const std::vector&lt; std::string &gt; &amp;labels)</td></tr>
<tr class="memdesc:a28aeb65b506bec147f76ec3efe49f9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return raw labels mapped to sublayers given a vector of formatted labels.  <a href="#a28aeb65b506bec147f76ec3efe49f9ef">More...</a><br /></td></tr>
<tr class="separator:a28aeb65b506bec147f76ec3efe49f9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab904a68f1bbe79c0e1c42c1c9042bc8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a> (void)</td></tr>
<tr class="memdesc:ab904a68f1bbe79c0e1c42c1c9042bc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return global layer registry reference.  <a href="#ab904a68f1bbe79c0e1c42c1c9042bc8e">More...</a><br /></td></tr>
<tr class="separator:ab904a68f1bbe79c0e1c42c1c9042bc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0ceb56b01c40d48809e9555e0164af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a9b0ceb56b01c40d48809e9555e0164af">recursive_layer_tag</a> (<a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a> tens, std::string layer_type, std::string name, <a class="el" href="namespaceteq.html#a06d5cc6ba08f690e19ee8cf46d289993">teq::TensSetT</a> stops, <a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a> &amp;registry=<a class="el" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>())</td></tr>
<tr class="separator:a9b0ceb56b01c40d48809e9555e0164af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1f5afc84c0bb0f641c5b912ff0265b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#afafbe478fabdc9c0482dd4bb5759f285">LayerptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a6b1f5afc84c0bb0f641c5b912ff0265b">load_layer</a> (std::istream &amp;ins, <a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> &amp;roots, std::string ltype, std::string label, <a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a> &amp;registry=<a class="el" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>())</td></tr>
<tr class="separator:a6b1f5afc84c0bb0f641c5b912ff0265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378f457bebd8c4f90590858b2094be1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a378f457bebd8c4f90590858b2094be1f">save_layer</a> (std::ostream &amp;outs, const <a class="el" href="structlayr_1_1i_layer.html">iLayer</a> &amp;layer, <a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> roots, <a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a> &amp;registry=<a class="el" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>())</td></tr>
<tr class="separator:a378f457bebd8c4f90590858b2094be1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddc83cd51abc9d9aa9db0747e330807"><td class="memItemLeft" align="right" valign="top">NodeptrT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#afddc83cd51abc9d9aa9db0747e330807">softmax_from_layer</a> (const <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a> &amp;layer, NodeptrT input)</td></tr>
<tr class="separator:afddc83cd51abc9d9aa9db0747e330807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb015e94c509568dbcd91d439db16fde"><td class="memItemLeft" align="right" valign="top">NodeptrT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#acb015e94c509568dbcd91d439db16fde">maxpool_from_layer</a> (const <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a> &amp;layer, NodeptrT input)</td></tr>
<tr class="separator:acb015e94c509568dbcd91d439db16fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d79fc4162ae2cfc5f8c1f878643051"><td class="memItemLeft" align="right" valign="top">NodeptrT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a88d79fc4162ae2cfc5f8c1f878643051">meanpool_from_layer</a> (const <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a> &amp;layer, NodeptrT input)</td></tr>
<tr class="separator:a88d79fc4162ae2cfc5f8c1f878643051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184e594711ef2ec9473643299556db90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a184e594711ef2ec9473643299556db90">sigmoid</a> (void)</td></tr>
<tr class="memdesc:a184e594711ef2ec9473643299556db90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return activation layer using sigmoid.  <a href="#a184e594711ef2ec9473643299556db90">More...</a><br /></td></tr>
<tr class="separator:a184e594711ef2ec9473643299556db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc41da40ab1fecc7218b458237e0405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a1cc41da40ab1fecc7218b458237e0405">tanh</a> (void)</td></tr>
<tr class="memdesc:a1cc41da40ab1fecc7218b458237e0405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return activation layer using tanh.  <a href="#a1cc41da40ab1fecc7218b458237e0405">More...</a><br /></td></tr>
<tr class="separator:a1cc41da40ab1fecc7218b458237e0405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f51b6a821932595f12cdf81826dd430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a3f51b6a821932595f12cdf81826dd430">softmax</a> (<a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> dim)</td></tr>
<tr class="memdesc:a3f51b6a821932595f12cdf81826dd430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return activation layer using softmax of specified dimension.  <a href="#a3f51b6a821932595f12cdf81826dd430">More...</a><br /></td></tr>
<tr class="separator:a3f51b6a821932595f12cdf81826dd430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa763b560b022d6fe78619e595a6f83a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#aa763b560b022d6fe78619e595a6f83a4">maxpool2d</a> (std::pair&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a>, <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt; dims={0, 1})</td></tr>
<tr class="memdesc:aa763b560b022d6fe78619e595a6f83a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pooling layer using max aggregation.  <a href="#aa763b560b022d6fe78619e595a6f83a4">More...</a><br /></td></tr>
<tr class="separator:aa763b560b022d6fe78619e595a6f83a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89c731ff4fed6c78b1791c8266d1343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#aa89c731ff4fed6c78b1791c8266d1343">meanpool2d</a> (std::pair&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a>, <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt; dims={0, 1})</td></tr>
<tr class="memdesc:aa89c731ff4fed6c78b1791c8266d1343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pooling layer using mean aggregation.  <a href="#aa89c731ff4fed6c78b1791c8266d1343">More...</a><br /></td></tr>
<tr class="separator:aa89c731ff4fed6c78b1791c8266d1343"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aedfdefde1de9de9f3ac2745406a96f40"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#aedfdefde1de9de9f3ac2745406a96f40">conv_weight_key</a> = &quot;weight&quot;</td></tr>
<tr class="memdesc:aedfdefde1de9de9f3ac2745406a96f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolutional weight label.  <a href="#aedfdefde1de9de9f3ac2745406a96f40">More...</a><br /></td></tr>
<tr class="separator:aedfdefde1de9de9f3ac2745406a96f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baad594f57afcb242a9b6830a0c17c0"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a1baad594f57afcb242a9b6830a0c17c0">conv_bias_key</a> = &quot;bias&quot;</td></tr>
<tr class="memdesc:a1baad594f57afcb242a9b6830a0c17c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolutional bias label.  <a href="#a1baad594f57afcb242a9b6830a0c17c0">More...</a><br /></td></tr>
<tr class="separator:a1baad594f57afcb242a9b6830a0c17c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29006a29e0046a6facbc193ba463df87"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a29006a29e0046a6facbc193ba463df87">conv_layer_key</a></td></tr>
<tr class="memdesc:a29006a29e0046a6facbc193ba463df87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for convolutional layer.  <a href="#a29006a29e0046a6facbc193ba463df87">More...</a><br /></td></tr>
<tr class="separator:a29006a29e0046a6facbc193ba463df87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d80c71d78d38faa513a013fbac9d2f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#ad7d80c71d78d38faa513a013fbac9d2f">dense_weight_key</a> = &quot;weight&quot;</td></tr>
<tr class="memdesc:ad7d80c71d78d38faa513a013fbac9d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully connected weight label.  <a href="#ad7d80c71d78d38faa513a013fbac9d2f">More...</a><br /></td></tr>
<tr class="separator:ad7d80c71d78d38faa513a013fbac9d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5876ef2249893a0d6de0fa8c0e7963f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#ab5876ef2249893a0d6de0fa8c0e7963f">dense_bias_key</a> = &quot;bias&quot;</td></tr>
<tr class="memdesc:ab5876ef2249893a0d6de0fa8c0e7963f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully connected bias label.  <a href="#ab5876ef2249893a0d6de0fa8c0e7963f">More...</a><br /></td></tr>
<tr class="separator:ab5876ef2249893a0d6de0fa8c0e7963f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d4793cbe867282851a519be366260c"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a25d4793cbe867282851a519be366260c">dense_layer_key</a></td></tr>
<tr class="memdesc:a25d4793cbe867282851a519be366260c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for fully connected layer.  <a href="#a25d4793cbe867282851a519be366260c">More...</a><br /></td></tr>
<tr class="separator:a25d4793cbe867282851a519be366260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b9ec098f4c0bd0b0af267d13dc61c2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> = &quot;layer_&quot;</td></tr>
<tr class="memdesc:ae4b9ec098f4c0bd0b0af267d13dc61c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">String prefixed to every layer key.  <a href="#ae4b9ec098f4c0bd0b0af267d13dc61c2">More...</a><br /></td></tr>
<tr class="separator:ae4b9ec098f4c0bd0b0af267d13dc61c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb00b61434c3d6c87ac6a5341a048b83"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#abb00b61434c3d6c87ac6a5341a048b83">llabel_sep</a> = ':'</td></tr>
<tr class="memdesc:abb00b61434c3d6c87ac6a5341a048b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer label separator to divide each element in the <a class="el" href="structlayr_1_1_layer_id.html" title="Sublayer type, label, and index encapsulation. ">LayerId</a>.  <a href="#abb00b61434c3d6c87ac6a5341a048b83">More...</a><br /></td></tr>
<tr class="separator:abb00b61434c3d6c87ac6a5341a048b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e7fed67248500119e7fa83ea406359"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a66e7fed67248500119e7fa83ea406359">hidden_key</a> = &quot;hidden&quot;</td></tr>
<tr class="memdesc:a66e7fed67248500119e7fa83ea406359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hidden fully connected layer label.  <a href="#a66e7fed67248500119e7fa83ea406359">More...</a><br /></td></tr>
<tr class="separator:a66e7fed67248500119e7fa83ea406359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5d91cb939794e91c2070767460f15b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a2b5d91cb939794e91c2070767460f15b">visible_key</a> = &quot;visible&quot;</td></tr>
<tr class="memdesc:a2b5d91cb939794e91c2070767460f15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visible fully connected layer label.  <a href="#a2b5d91cb939794e91c2070767460f15b">More...</a><br /></td></tr>
<tr class="separator:a2b5d91cb939794e91c2070767460f15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1bdfc17f04ebac51b0ac8d8cad5018"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#acb1bdfc17f04ebac51b0ac8d8cad5018">rbm_layer_key</a></td></tr>
<tr class="memdesc:acb1bdfc17f04ebac51b0ac8d8cad5018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for restricted boltzmann machine.  <a href="#acb1bdfc17f04ebac51b0ac8d8cad5018">More...</a><br /></td></tr>
<tr class="separator:acb1bdfc17f04ebac51b0ac8d8cad5018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81720a2006f1764c847eb00605e4c36b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a81720a2006f1764c847eb00605e4c36b">seq_model_key</a></td></tr>
<tr class="memdesc:a81720a2006f1764c847eb00605e4c36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for sequentially connected models.  <a href="#a81720a2006f1764c847eb00605e4c36b">More...</a><br /></td></tr>
<tr class="separator:a81720a2006f1764c847eb00605e4c36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5b3c86b2a016826188c7b3f1e108e6"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a3e5b3c86b2a016826188c7b3f1e108e6">sigmoid_layer_key</a></td></tr>
<tr class="memdesc:a3e5b3c86b2a016826188c7b3f1e108e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for sigmoid activation layer.  <a href="#a3e5b3c86b2a016826188c7b3f1e108e6">More...</a><br /></td></tr>
<tr class="separator:a3e5b3c86b2a016826188c7b3f1e108e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fae99825b43e9773cf1560bd155a556"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a4fae99825b43e9773cf1560bd155a556">tanh_layer_key</a></td></tr>
<tr class="memdesc:a4fae99825b43e9773cf1560bd155a556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for tanh activation layer.  <a href="#a4fae99825b43e9773cf1560bd155a556">More...</a><br /></td></tr>
<tr class="separator:a4fae99825b43e9773cf1560bd155a556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a160a810a88a79635d87098a19593e"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a60a160a810a88a79635d87098a19593e">softmax_layer_key</a></td></tr>
<tr class="memdesc:a60a160a810a88a79635d87098a19593e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for softmax activation layer.  <a href="#a60a160a810a88a79635d87098a19593e">More...</a><br /></td></tr>
<tr class="separator:a60a160a810a88a79635d87098a19593e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2314f63ba326d6a200e16b2ebbbc8fb2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a2314f63ba326d6a200e16b2ebbbc8fb2">maxpool2d_layer_key</a></td></tr>
<tr class="memdesc:a2314f63ba326d6a200e16b2ebbbc8fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for max pooling layer.  <a href="#a2314f63ba326d6a200e16b2ebbbc8fb2">More...</a><br /></td></tr>
<tr class="separator:a2314f63ba326d6a200e16b2ebbbc8fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5681d957e461518e00ede3608b3f60d"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#ae5681d957e461518e00ede3608b3f60d">meanpool2d_layer_key</a></td></tr>
<tr class="memdesc:ae5681d957e461518e00ede3608b3f60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for mean pooling layer.  <a href="#ae5681d957e461518e00ede3608b3f60d">More...</a><br /></td></tr>
<tr class="separator:ae5681d957e461518e00ede3608b3f60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dddbb65adc0e95873a9bcaf20832f9"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; std::string, <a class="el" href="namespacelayr.html#aad1df0c3b4774d80511748e06f4dfd9f">UnaryF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelayr.html#a48dddbb65adc0e95873a9bcaf20832f9">unaries</a></td></tr>
<tr class="memdesc:a48dddbb65adc0e95873a9bcaf20832f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map unary layer identifier to connection function.  <a href="#a48dddbb65adc0e95873a9bcaf20832f9">More...</a><br /></td></tr>
<tr class="separator:a48dddbb65adc0e95873a9bcaf20832f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="err__approx_8hpp.html">err_approx.hpp</a> layr</p>
<p>Purpose: Define error approximation algorithms and variable assignment utilities</p>
<p><a class="el" href="init_8hpp.html">init.hpp</a> layr</p>
<p>Purpose: Define variable initialization algorithms</p>
<p><a class="el" href="layer_8hpp.html">layer.hpp</a> layr</p>
<p>Purpose: Define layer interface and tagging</p>
<p><a class="el" href="seqmodel_8hpp.html">seqmodel.hpp</a> layr</p>
<p>Purpose: Implement sequentially connected model</p>
<p><a class="el" href="ulayer_8hpp.html">ulayer.hpp</a> layr</p>
<p>Purpose: Implement generic layer that applies unary functions these functions don't store any data </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a83ea27d659d3cee1503e52d07c942d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ea27d659d3cee1503e52d07c942d0e">&#9670;&nbsp;</a></span>ApproxF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#a83ea27d659d3cee1503e52d07c942d0e">layr::ApproxF</a> = typedef std::function&lt;<a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a>(const <a class="el" href="namespacelayr.html#afa9f6661ecd0f52f8a3507ff0c238842">VarErrsT</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that approximate error of sources given a vector of variables and its corresponding errors </p>

</div>
</div>
<a id="a5fd616a9b8451b1ac5f451f1589f7983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd616a9b8451b1ac5f451f1589f7983">&#9670;&nbsp;</a></span>AssignGroupsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">layr::AssignGroupsT</a> = typedef std::vector&lt;<a class="el" href="namespacelayr.html#aaa44ed30c9507630e97563964b1b2e5d">AssignsT</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All batches of assignments. </p>

</div>
</div>
<a id="aaa44ed30c9507630e97563964b1b2e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa44ed30c9507630e97563964b1b2e5d">&#9670;&nbsp;</a></span>AssignsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#aaa44ed30c9507630e97563964b1b2e5d">layr::AssignsT</a> = typedef std::vector&lt;<a class="el" href="structlayr_1_1_var_assign.html">VarAssign</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One batch of assignments. </p>

</div>
</div>
<a id="a37a651019f5790e7f92a4a5f2db5df52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a651019f5790e7f92a4a5f2db5df52">&#9670;&nbsp;</a></span>ConvptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#a37a651019f5790e7f92a4a5f2db5df52">layr::ConvptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structlayr_1_1_conv.html">Conv</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of convolutional layer. </p>

</div>
</div>
<a id="ae06ffe9ce80e1d23a39f79c4dc7cc4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06ffe9ce80e1d23a39f79c4dc7cc4c9">&#9670;&nbsp;</a></span>DenseptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#ae06ffe9ce80e1d23a39f79c4dc7cc4c9">layr::DenseptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structlayr_1_1_dense.html">Dense</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of fully connected layer. </p>

</div>
</div>
<a id="aa8d4e642c6e804bca85f0ea1b7bae15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d4e642c6e804bca85f0ea1b7bae15b">&#9670;&nbsp;</a></span>InitF</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">layr::InitF</a> = typedef std::function&lt;<a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">eteq::VarptrT</a>&lt;T&gt;(<a class="el" href="structteq_1_1_shape.html">teq::Shape</a>,std::string)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that produces a variable given the variable's shape and label. </p>

</div>
</div>
<a id="af0df474a71266252c2652402471fff99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0df474a71266252c2652402471fff99">&#9670;&nbsp;</a></span>LayerBuildF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#af0df474a71266252c2652402471fff99">layr::LayerBuildF</a> = typedef std::function&lt;<a class="el" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a>(std::string)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that takes layer type and returns associated layer builder. </p>

</div>
</div>
<a id="a2999f55c6588e8e62c63f21cfd9581fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2999f55c6588e8e62c63f21cfd9581fc">&#9670;&nbsp;</a></span>LayerIdsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#a2999f55c6588e8e62c63f21cfd9581fc">layr::LayerIdsT</a> = typedef std::vector&lt;<a class="el" href="structlayr_1_1_layer_id.html">LayerId</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of sublayer ids. </p>

</div>
</div>
<a id="afafbe478fabdc9c0482dd4bb5759f285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafbe478fabdc9c0482dd4bb5759f285">&#9670;&nbsp;</a></span>LayerptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#afafbe478fabdc9c0482dd4bb5759f285">layr::LayerptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structlayr_1_1i_layer.html">iLayer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of layer. </p>

</div>
</div>
<a id="acbbe8de1349b0415b6d24f5377522b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbe8de1349b0415b6d24f5377522b28">&#9670;&nbsp;</a></span>LBuilderptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structlayr_1_1i_layer_builder.html">iLayerBuilder</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Layer builder smart pointer. </p>

</div>
</div>
<a id="a4e187a48b5bebf9f04e7f95ce560cb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e187a48b5bebf9f04e7f95ce560cb69">&#9670;&nbsp;</a></span>RBMptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#a4e187a48b5bebf9f04e7f95ce560cb69">layr::RBMptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structlayr_1_1_r_b_m.html">RBM</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of <a class="el" href="structlayr_1_1_r_b_m.html">RBM</a> layer. </p>

</div>
</div>
<a id="a71287ab7fdb69f470d1cb6b672a681da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71287ab7fdb69f470d1cb6b672a681da">&#9670;&nbsp;</a></span>SeqModelptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#a71287ab7fdb69f470d1cb6b672a681da">layr::SeqModelptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structlayr_1_1_sequential_model.html">SequentialModel</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of sequentially connected model. </p>

</div>
</div>
<a id="adaa34b531ef5803cd9a5242ff031d7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa34b531ef5803cd9a5242ff031d7b9">&#9670;&nbsp;</a></span>ShapeFactorF</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#adaa34b531ef5803cd9a5242ff031d7b9">layr::ShapeFactorF</a> = typedef std::function&lt;T(<a class="el" href="structteq_1_1_shape.html">teq::Shape</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that returns some metric of a shape. </p>

</div>
</div>
<a id="aad1df0c3b4774d80511748e06f4dfd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1df0c3b4774d80511748e06f4dfd9f">&#9670;&nbsp;</a></span>UnaryF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#aad1df0c3b4774d80511748e06f4dfd9f">layr::UnaryF</a> = typedef std::function&lt;NodeptrT( const <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a>&amp;,NodeptrT)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that takes corresponding unary layer and node. </p>

</div>
</div>
<a id="acd75d90f3b421949f491559fcfe49be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd75d90f3b421949f491559fcfe49be9">&#9670;&nbsp;</a></span>UnaryptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">layr::UnaryptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structlayr_1_1_u_layer.html">ULayer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of unary layer. </p>

</div>
</div>
<a id="a63cfcd30444af970454ad839af3eee85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cfcd30444af970454ad839af3eee85">&#9670;&nbsp;</a></span>UpdateStepF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#a63cfcd30444af970454ad839af3eee85">layr::UpdateStepF</a> = typedef std::function&lt;void(<a class="el" href="namespaceteq.html#a06d5cc6ba08f690e19ee8cf46d289993">teq::TensSetT</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that runs before or after variable assignment to calculate approximation graphs </p>

</div>
</div>
<a id="afa9f6661ecd0f52f8a3507ff0c238842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9f6661ecd0f52f8a3507ff0c238842">&#9670;&nbsp;</a></span>VarErrsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacelayr.html#afa9f6661ecd0f52f8a3507ff0c238842">layr::VarErrsT</a> = typedef std::vector&lt;std::pair&lt;<a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">eteq::VarptrT</a>&lt;PybindT&gt;,NodeptrT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ordered association between variable and error. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5c41fa39bdd87ddcf75ca3f44ebafe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c41fa39bdd87ddcf75ca3f44ebafe6e">&#9670;&nbsp;</a></span>assign_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layr::assign_groups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a> &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelayr.html#a63cfcd30444af970454ad839af3eee85">UpdateStepF</a>&#160;</td>
          <td class="paramname"><em>update_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply all batches of assignments with update_step applied after each batch. </p>

</div>
</div>
<a id="a47031f1ccfaef5e2b7e69e90b47d786c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47031f1ccfaef5e2b7e69e90b47d786c">&#9670;&nbsp;</a></span>assign_groups_preupdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layr::assign_groups_preupdate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a> &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelayr.html#a63cfcd30444af970454ad839af3eee85">UpdateStepF</a>&#160;</td>
          <td class="paramname"><em>update_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply all batches of assignments with update_step applied before each batch. </p>

</div>
</div>
<a id="a925fffac0436c9a8659ba847741d1283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925fffac0436c9a8659ba847741d1283">&#9670;&nbsp;</a></span>fanavg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T layr::fanavg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the mean of the first 2 dimensions of a shape. </p>

</div>
</div>
<a id="a6f584c9d897ad1f661dc9eb570f4407f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f584c9d897ad1f661dc9eb570f4407f">&#9670;&nbsp;</a></span>fanio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T layr::fanio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sum of the first 2 dimensions of a shape. </p>

</div>
</div>
<a id="ab904a68f1bbe79c0e1c42c1c9042bc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab904a68f1bbe79c0e1c42c1c9042bc8e">&#9670;&nbsp;</a></span>get_layer_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a>&amp; layr::get_layer_reg </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return global layer registry reference. </p>

</div>
</div>
<a id="ab4358db53a9feefdd2150425d1849b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4358db53a9feefdd2150425d1849b01">&#9670;&nbsp;</a></span>layer_label_fmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string layr::layer_label_fmt </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlayr_1_1_layer_id.html">LayerId</a>&#160;</td>
          <td class="paramname"><em>subid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return formatted raw label with associated sublayer. </p>

</div>
</div>
<a id="a6b1f5afc84c0bb0f641c5b912ff0265b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1f5afc84c0bb0f641c5b912ff0265b">&#9670;&nbsp;</a></span>load_layer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#afafbe478fabdc9c0482dd4bb5759f285">LayerptrT</a> layr::load_layer </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>ins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ltype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em> = <code><a class="el" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a rebuilt layer from protobuf in stream (ins) a bunch of subgraph roots and the output layer's type and label </p>

</div>
</div>
<a id="aa763b560b022d6fe78619e595a6f83a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa763b560b022d6fe78619e595a6f83a4">&#9670;&nbsp;</a></span>maxpool2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a> layr::maxpool2d </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a>, <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt;&#160;</td>
          <td class="paramname"><em>dims</em> = <code>{0,&#160;1}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pooling layer using max aggregation. </p>

</div>
</div>
<a id="acb015e94c509568dbcd91d439db16fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb015e94c509568dbcd91d439db16fde">&#9670;&nbsp;</a></span>maxpool_from_layer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeptrT layr::maxpool_from_layer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeptrT&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa89c731ff4fed6c78b1791c8266d1343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89c731ff4fed6c78b1791c8266d1343">&#9670;&nbsp;</a></span>meanpool2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a> layr::meanpool2d </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a>, <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt;&#160;</td>
          <td class="paramname"><em>dims</em> = <code>{0,&#160;1}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pooling layer using mean aggregation. </p>

</div>
</div>
<a id="a88d79fc4162ae2cfc5f8c1f878643051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d79fc4162ae2cfc5f8c1f878643051">&#9670;&nbsp;</a></span>meanpool_from_layer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeptrT layr::meanpool_from_layer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeptrT&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01ca48af51216db64440ffc509150ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ca48af51216db64440ffc509150ddb">&#9670;&nbsp;</a></span>norm_xavier_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a>&lt;T&gt; layr::norm_xavier_init </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return initialization function that makes xavier initialized variables (that uses gaussian distribution) (see <a href="https://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization">https://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization</a>) </p>

</div>
</div>
<a id="a9b0ceb56b01c40d48809e9555e0164af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0ceb56b01c40d48809e9555e0164af">&#9670;&nbsp;</a></span>recursive_layer_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layr::recursive_layer_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a>&#160;</td>
          <td class="paramname"><em>tens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>layer_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#a06d5cc6ba08f690e19ee8cf46d289993">teq::TensSetT</a>&#160;</td>
          <td class="paramname"><em>stops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em> = <code><a class="el" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursively tag tensor subgraph with specified layer type, and label only ignoring subgraphs of tensors in stops set </p>

</div>
</div>
<a id="ac87e6083795256c7676a3464a1f1b6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87e6083795256c7676a3464a1f1b6a5">&#9670;&nbsp;</a></span>rms_momentum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a> layr::rms_momentum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelayr.html#afa9f6661ecd0f52f8a3507ff0c238842">VarErrsT</a> &amp;&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PybindT&#160;</td>
          <td class="paramname"><em>learning_rate</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PybindT&#160;</td>
          <td class="paramname"><em>discount_factor</em> = <code>0.99</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PybindT&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>std::numeric_limits&lt;PybindT&gt;::epsilon()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>root_label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return all batches of variable assignments of momentum-based rms error approximation applied to particular variables-error associations</p>
<p>Momentum-based Root Mean Square Approximation for each (x, err) in leaves momentum_next ~ χ * momentum_cur + (1 - χ) * err ^ 2 x_next ~ x_curr - (η * err) / (sqrt(ε + momentum_next))</p>
<p>where η is the learning rate, ε is epsilon, and χ is discount_factor initial momentum is 1 </p>

</div>
</div>
<a id="a378f457bebd8c4f90590858b2094be1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378f457bebd8c4f90590858b2094be1f">&#9670;&nbsp;</a></span>save_layer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool layr::save_layer </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlayr_1_1i_layer.html">iLayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a>&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlayr_1_1_layer_registry.html">LayerRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em> = <code><a class="el" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if specified layer and root subgraphs are saved to protobuf out stream (outs) </p>

</div>
</div>
<a id="a9e8d161ff4a643d41292f56938a29a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8d161ff4a643d41292f56938a29a82">&#9670;&nbsp;</a></span>sgd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#a5fd616a9b8451b1ac5f451f1589f7983">AssignGroupsT</a> layr::sgd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelayr.html#afa9f6661ecd0f52f8a3507ff0c238842">VarErrsT</a> &amp;&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PybindT&#160;</td>
          <td class="paramname"><em>learning_rate</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>root_label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return all batches of variable assignments of stochastic gradient descent error approximation applied to particular variables-error associations</p>
<p>Stochastic Gradient Descent Approximation for each (x, err) in leaves x_next ~ x_curr - η * err,</p>
<p>where η is the learning rate </p>

</div>
</div>
<a id="a184e594711ef2ec9473643299556db90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184e594711ef2ec9473643299556db90">&#9670;&nbsp;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a> layr::sigmoid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return activation layer using sigmoid. </p>

</div>
</div>
<a id="a3f51b6a821932595f12cdf81826dd430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f51b6a821932595f12cdf81826dd430">&#9670;&nbsp;</a></span>softmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a> layr::softmax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return activation layer using softmax of specified dimension. </p>

</div>
</div>
<a id="afddc83cd51abc9d9aa9db0747e330807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddc83cd51abc9d9aa9db0747e330807">&#9670;&nbsp;</a></span>softmax_from_layer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeptrT layr::softmax_from_layer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlayr_1_1_u_layer.html">ULayer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeptrT&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Softmax layer connection function that extracts transformation parameter from layer and apply to input </p>

</div>
</div>
<a id="a1cc41da40ab1fecc7218b458237e0405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc41da40ab1fecc7218b458237e0405">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#acd75d90f3b421949f491559fcfe49be9">UnaryptrT</a> layr::tanh </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return activation layer using tanh. </p>

</div>
</div>
<a id="a93d021587dfe7fd257e43d2137960158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d021587dfe7fd257e43d2137960158">&#9670;&nbsp;</a></span>truncated_normal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void layr::truncated_normal </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_repick</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate out vector with normally distributed values (using mean and stdev) except repick values if the value is not within 2 stdev of the mean </p>

</div>
</div>
<a id="adc309fed2a58080955d89ee20361a8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc309fed2a58080955d89ee20361a8d4">&#9670;&nbsp;</a></span>unif_xavier_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a>&lt;T&gt; layr::unif_xavier_init </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return initialization function that makes xavier initialized variables (that uses uniform distribution) (see <a href="https://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization">https://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization</a>) </p>

</div>
</div>
<a id="a28aeb65b506bec147f76ec3efe49f9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28aeb65b506bec147f76ec3efe49f9ef">&#9670;&nbsp;</a></span>unpack_labels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string,<a class="el" href="namespacelayr.html#a2999f55c6588e8e62c63f21cfd9581fc">LayerIdsT</a>&gt; layr::unpack_labels </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return raw labels mapped to sublayers given a vector of formatted labels. </p>

</div>
</div>
<a id="a7ad082dc95f94d4dee08a6db2703fb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad082dc95f94d4dee08a6db2703fb13">&#9670;&nbsp;</a></span>validate_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layr::validate_label </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the raw label does not contain llabel_sep as to not clash with <a class="el" href="structlayr_1_1_layer_id.html" title="Sublayer type, label, and index encapsulation. ">LayerId</a> representation </p>

</div>
</div>
<a id="afd7378022d7e5649b3d8d56505744f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7378022d7e5649b3d8d56505744f51">&#9670;&nbsp;</a></span>variance_scaling_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a>&lt;T&gt; layr::variance_scaling_init </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelayr.html#adaa34b531ef5803cd9a5242ff031d7b9">ShapeFactorF</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>sfactor</em> = <code><a class="el" href="namespacelayr.html#a925fffac0436c9a8659ba847741d1283">fanavg</a>&lt;T&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return initialization function that makes variance scaling variables (see <a href="https://www.tensorflow.org/versions/r1.14/api_docs/python/tf/contrib/layers/variance_scaling_initializer">https://www.tensorflow.org/versions/r1.14/api_docs/python/tf/contrib/layers/variance_scaling_initializer</a>) </p>

</div>
</div>
<a id="acadef664ac3354e08fcf2170933d702f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadef664ac3354e08fcf2170933d702f">&#9670;&nbsp;</a></span>zero_init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelayr.html#aa8d4e642c6e804bca85f0ea1b7bae15b">InitF</a>&lt;T&gt; layr::zero_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return initialization function that makes zero variables. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1baad594f57afcb242a9b6830a0c17c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1baad594f57afcb242a9b6830a0c17c0">&#9670;&nbsp;</a></span>conv_bias_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::conv_bias_key = &quot;bias&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolutional bias label. </p>

</div>
</div>
<a id="a29006a29e0046a6facbc193ba463df87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29006a29e0046a6facbc193ba463df87">&#9670;&nbsp;</a></span>conv_layer_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::conv_layer_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;conv&quot;</span>,</div><div class="line">[](std::string label) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;ConvBuilder&gt;(label);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
</div><!-- fragment -->
<p>Identifier for convolutional layer. </p>

</div>
</div>
<a id="aedfdefde1de9de9f3ac2745406a96f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfdefde1de9de9f3ac2745406a96f40">&#9670;&nbsp;</a></span>conv_weight_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::conv_weight_key = &quot;weight&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolutional weight label. </p>

</div>
</div>
<a id="ab5876ef2249893a0d6de0fa8c0e7963f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5876ef2249893a0d6de0fa8c0e7963f">&#9670;&nbsp;</a></span>dense_bias_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::dense_bias_key = &quot;bias&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully connected bias label. </p>

</div>
</div>
<a id="a25d4793cbe867282851a519be366260c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d4793cbe867282851a519be366260c">&#9670;&nbsp;</a></span>dense_layer_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::dense_layer_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;dense&quot;</span>,</div><div class="line">[](std::string label) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;DenseBuilder&gt;(label);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
</div><!-- fragment -->
<p>Identifier for fully connected layer. </p>

</div>
</div>
<a id="ad7d80c71d78d38faa513a013fbac9d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d80c71d78d38faa513a013fbac9d2f">&#9670;&nbsp;</a></span>dense_weight_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::dense_weight_key = &quot;weight&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully connected weight label. </p>

</div>
</div>
<a id="a66e7fed67248500119e7fa83ea406359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e7fed67248500119e7fa83ea406359">&#9670;&nbsp;</a></span>hidden_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::hidden_key = &quot;hidden&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hidden fully connected layer label. </p>

</div>
</div>
<a id="ae4b9ec098f4c0bd0b0af267d13dc61c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b9ec098f4c0bd0b0af267d13dc61c2">&#9670;&nbsp;</a></span>layers_key_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::layers_key_prefix = &quot;layer_&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String prefixed to every layer key. </p>

</div>
</div>
<a id="abb00b61434c3d6c87ac6a5341a048b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb00b61434c3d6c87ac6a5341a048b83">&#9670;&nbsp;</a></span>llabel_sep</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char layr::llabel_sep = ':'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Layer label separator to divide each element in the <a class="el" href="structlayr_1_1_layer_id.html" title="Sublayer type, label, and index encapsulation. ">LayerId</a>. </p>

</div>
</div>
<a id="a2314f63ba326d6a200e16b2ebbbc8fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2314f63ba326d6a200e16b2ebbbc8fb2">&#9670;&nbsp;</a></span>maxpool2d_layer_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::maxpool2d_layer_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;maxpool&quot;</span>,</div><div class="line">[](std::string extra_info) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;ULayerBuilder&gt;(<a class="code" href="namespacelayr.html#a2314f63ba326d6a200e16b2ebbbc8fb2">maxpool2d_layer_key</a>, extra_info);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
<div class="ttc" id="namespacelayr_html_a2314f63ba326d6a200e16b2ebbbc8fb2"><div class="ttname"><a href="namespacelayr.html#a2314f63ba326d6a200e16b2ebbbc8fb2">layr::maxpool2d_layer_key</a></div><div class="ttdeci">const std::string maxpool2d_layer_key</div><div class="ttdoc">Identifier for max pooling layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:72</div></div>
</div><!-- fragment -->
<p>Identifier for max pooling layer. </p>

</div>
</div>
<a id="ae5681d957e461518e00ede3608b3f60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5681d957e461518e00ede3608b3f60d">&#9670;&nbsp;</a></span>meanpool2d_layer_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::meanpool2d_layer_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;meanpool&quot;</span>,</div><div class="line">[](std::string extra_info) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;ULayerBuilder&gt;(<a class="code" href="namespacelayr.html#ae5681d957e461518e00ede3608b3f60d">meanpool2d_layer_key</a>, extra_info);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
<div class="ttc" id="namespacelayr_html_ae5681d957e461518e00ede3608b3f60d"><div class="ttname"><a href="namespacelayr.html#ae5681d957e461518e00ede3608b3f60d">layr::meanpool2d_layer_key</a></div><div class="ttdeci">const std::string meanpool2d_layer_key</div><div class="ttdoc">Identifier for mean pooling layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:80</div></div>
</div><!-- fragment -->
<p>Identifier for mean pooling layer. </p>

</div>
</div>
<a id="acb1bdfc17f04ebac51b0ac8d8cad5018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1bdfc17f04ebac51b0ac8d8cad5018">&#9670;&nbsp;</a></span>rbm_layer_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::rbm_layer_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;rbm&quot;</span>,</div><div class="line">[](std::string label) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;RBMBuilder&gt;(label);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
</div><!-- fragment -->
<p>Identifier for restricted boltzmann machine. </p>

</div>
</div>
<a id="a81720a2006f1764c847eb00605e4c36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81720a2006f1764c847eb00605e4c36b">&#9670;&nbsp;</a></span>seq_model_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::seq_model_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;seqmodel&quot;</span>,</div><div class="line">[](std::string label) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;SeqModelBuilder&gt;(label);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
</div><!-- fragment -->
<p>Identifier for sequentially connected models. </p>

</div>
</div>
<a id="a3e5b3c86b2a016826188c7b3f1e108e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5b3c86b2a016826188c7b3f1e108e6">&#9670;&nbsp;</a></span>sigmoid_layer_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::sigmoid_layer_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;sigmoid&quot;</span>,</div><div class="line">[](std::string extra_info) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;ULayerBuilder&gt;(<a class="code" href="namespacelayr.html#a3e5b3c86b2a016826188c7b3f1e108e6">sigmoid_layer_key</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_a3e5b3c86b2a016826188c7b3f1e108e6"><div class="ttname"><a href="namespacelayr.html#a3e5b3c86b2a016826188c7b3f1e108e6">layr::sigmoid_layer_key</a></div><div class="ttdeci">const std::string sigmoid_layer_key</div><div class="ttdoc">Identifier for sigmoid activation layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:48</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
</div><!-- fragment -->
<p>Identifier for sigmoid activation layer. </p>

</div>
</div>
<a id="a60a160a810a88a79635d87098a19593e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a160a810a88a79635d87098a19593e">&#9670;&nbsp;</a></span>softmax_layer_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::softmax_layer_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;softmax&quot;</span>,</div><div class="line">[](std::string extra_info) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;ULayerBuilder&gt;(<a class="code" href="namespacelayr.html#a60a160a810a88a79635d87098a19593e">softmax_layer_key</a>, extra_info);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
<div class="ttc" id="namespacelayr_html_a60a160a810a88a79635d87098a19593e"><div class="ttname"><a href="namespacelayr.html#a60a160a810a88a79635d87098a19593e">layr::softmax_layer_key</a></div><div class="ttdeci">const std::string softmax_layer_key</div><div class="ttdoc">Identifier for softmax activation layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:64</div></div>
</div><!-- fragment -->
<p>Identifier for softmax activation layer. </p>

</div>
</div>
<a id="a4fae99825b43e9773cf1560bd155a556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fae99825b43e9773cf1560bd155a556">&#9670;&nbsp;</a></span>tanh_layer_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::tanh_layer_key</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"><a class="code" href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">get_layer_reg</a>().<a class="code" href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">register_tagr</a>(<a class="code" href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layers_key_prefix</a> + <span class="stringliteral">&quot;tanh&quot;</span>,</div><div class="line">[](std::string extra_info) -&gt; <a class="code" href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">LBuilderptrT</a></div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;ULayerBuilder&gt;(<a class="code" href="namespacelayr.html#a4fae99825b43e9773cf1560bd155a556">tanh_layer_key</a>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">})</div><div class="ttc" id="namespacelayr_html_a4fae99825b43e9773cf1560bd155a556"><div class="ttname"><a href="namespacelayr.html#a4fae99825b43e9773cf1560bd155a556">layr::tanh_layer_key</a></div><div class="ttdeci">const std::string tanh_layer_key</div><div class="ttdoc">Identifier for tanh activation layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:56</div></div>
<div class="ttc" id="namespacelayr_html_ab904a68f1bbe79c0e1c42c1c9042bc8e"><div class="ttname"><a href="namespacelayr.html#ab904a68f1bbe79c0e1c42c1c9042bc8e">layr::get_layer_reg</a></div><div class="ttdeci">LayerRegistry &amp; get_layer_reg(void)</div><div class="ttdoc">Return global layer registry reference. </div></div>
<div class="ttc" id="structlayr_1_1_layer_registry_html_aeb9c9d72f3a2f74736877d32039848a8"><div class="ttname"><a href="structlayr_1_1_layer_registry.html#aeb9c9d72f3a2f74736877d32039848a8">layr::LayerRegistry::register_tagr</a></div><div class="ttdeci">std::string register_tagr(std::string key, LayerBuildF builder)</div><div class="ttdef"><b>Definition:</b> layer.hpp:198</div></div>
<div class="ttc" id="namespacelayr_html_acbbe8de1349b0415b6d24f5377522b28"><div class="ttname"><a href="namespacelayr.html#acbbe8de1349b0415b6d24f5377522b28">layr::LBuilderptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iLayerBuilder &gt; LBuilderptrT</div><div class="ttdoc">Layer builder smart pointer. </div><div class="ttdef"><b>Definition:</b> layer.hpp:179</div></div>
<div class="ttc" id="namespacelayr_html_ae4b9ec098f4c0bd0b0af267d13dc61c2"><div class="ttname"><a href="namespacelayr.html#ae4b9ec098f4c0bd0b0af267d13dc61c2">layr::layers_key_prefix</a></div><div class="ttdeci">const std::string layers_key_prefix</div><div class="ttdoc">String prefixed to every layer key. </div><div class="ttdef"><b>Definition:</b> layer.hpp:25</div></div>
</div><!-- fragment -->
<p>Identifier for tanh activation layer. </p>

</div>
</div>
<a id="a48dddbb65adc0e95873a9bcaf20832f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dddbb65adc0e95873a9bcaf20832f9">&#9670;&nbsp;</a></span>unaries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt;std::string,<a class="el" href="namespacelayr.html#aad1df0c3b4774d80511748e06f4dfd9f">UnaryF</a>&gt; layr::unaries</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    {<a class="code" href="namespacelayr.html#a3e5b3c86b2a016826188c7b3f1e108e6">sigmoid_layer_key</a>,</div><div class="line">        [](<span class="keyword">const</span> ULayer&amp; layer, <a class="code" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a> input)</div><div class="line">        { <span class="keywordflow">return</span> tenncor::sigmoid&lt;PybindT&gt;(input); }},</div><div class="line">    {<a class="code" href="namespacelayr.html#a4fae99825b43e9773cf1560bd155a556">tanh_layer_key</a>,</div><div class="line">        [](<span class="keyword">const</span> ULayer&amp; layer, <a class="code" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a> input)</div><div class="line">        { <span class="keywordflow">return</span> tenncor::tanh&lt;PybindT&gt;(input); }},</div><div class="line">    {<a class="code" href="namespacelayr.html#a60a160a810a88a79635d87098a19593e">softmax_layer_key</a>, <a class="code" href="namespacelayr.html#afddc83cd51abc9d9aa9db0747e330807">softmax_from_layer</a>},</div><div class="line">    {<a class="code" href="namespacelayr.html#a2314f63ba326d6a200e16b2ebbbc8fb2">maxpool2d_layer_key</a>, <a class="code" href="namespacelayr.html#acb015e94c509568dbcd91d439db16fde">maxpool_from_layer</a>},</div><div class="line">    {<a class="code" href="namespacelayr.html#ae5681d957e461518e00ede3608b3f60d">meanpool2d_layer_key</a>, <a class="code" href="namespacelayr.html#a88d79fc4162ae2cfc5f8c1f878643051">meanpool_from_layer</a>},</div><div class="line">}</div><div class="ttc" id="namespacelayr_html_a4fae99825b43e9773cf1560bd155a556"><div class="ttname"><a href="namespacelayr.html#a4fae99825b43e9773cf1560bd155a556">layr::tanh_layer_key</a></div><div class="ttdeci">const std::string tanh_layer_key</div><div class="ttdoc">Identifier for tanh activation layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:56</div></div>
<div class="ttc" id="namespacelayr_html_a88d79fc4162ae2cfc5f8c1f878643051"><div class="ttname"><a href="namespacelayr.html#a88d79fc4162ae2cfc5f8c1f878643051">layr::meanpool_from_layer</a></div><div class="ttdeci">NodeptrT meanpool_from_layer(const ULayer &amp;layer, NodeptrT input)</div></div>
<div class="ttc" id="namespacelayr_html_a3e5b3c86b2a016826188c7b3f1e108e6"><div class="ttname"><a href="namespacelayr.html#a3e5b3c86b2a016826188c7b3f1e108e6">layr::sigmoid_layer_key</a></div><div class="ttdeci">const std::string sigmoid_layer_key</div><div class="ttdoc">Identifier for sigmoid activation layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:48</div></div>
<div class="ttc" id="namespacelayr_html_a2314f63ba326d6a200e16b2ebbbc8fb2"><div class="ttname"><a href="namespacelayr.html#a2314f63ba326d6a200e16b2ebbbc8fb2">layr::maxpool2d_layer_key</a></div><div class="ttdeci">const std::string maxpool2d_layer_key</div><div class="ttdoc">Identifier for max pooling layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:72</div></div>
<div class="ttc" id="namespacelayr_html_ae5681d957e461518e00ede3608b3f60d"><div class="ttname"><a href="namespacelayr.html#ae5681d957e461518e00ede3608b3f60d">layr::meanpool2d_layer_key</a></div><div class="ttdeci">const std::string meanpool2d_layer_key</div><div class="ttdoc">Identifier for mean pooling layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:80</div></div>
<div class="ttc" id="namespacelayr_html_a60a160a810a88a79635d87098a19593e"><div class="ttname"><a href="namespacelayr.html#a60a160a810a88a79635d87098a19593e">layr::softmax_layer_key</a></div><div class="ttdeci">const std::string softmax_layer_key</div><div class="ttdoc">Identifier for softmax activation layer. </div><div class="ttdef"><b>Definition:</b> ulayer.hpp:64</div></div>
<div class="ttc" id="namespaceeteq_html_a7cf4dd467ba202b498f9e1e1f6a4b604"><div class="ttname"><a href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">eteq::NodeptrT</a></div><div class="ttdeci">std::shared_ptr&lt; iNode&lt; T &gt; &gt; NodeptrT</div><div class="ttdoc">Smart pointer of node. </div><div class="ttdef"><b>Definition:</b> inode.hpp:63</div></div>
<div class="ttc" id="namespacelayr_html_afddc83cd51abc9d9aa9db0747e330807"><div class="ttname"><a href="namespacelayr.html#afddc83cd51abc9d9aa9db0747e330807">layr::softmax_from_layer</a></div><div class="ttdeci">NodeptrT softmax_from_layer(const ULayer &amp;layer, NodeptrT input)</div></div>
<div class="ttc" id="namespacelayr_html_acb015e94c509568dbcd91d439db16fde"><div class="ttname"><a href="namespacelayr.html#acb015e94c509568dbcd91d439db16fde">layr::maxpool_from_layer</a></div><div class="ttdeci">NodeptrT maxpool_from_layer(const ULayer &amp;layer, NodeptrT input)</div></div>
</div><!-- fragment -->
<p>Map unary layer identifier to connection function. </p>

</div>
</div>
<a id="a2b5d91cb939794e91c2070767460f15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5d91cb939794e91c2070767460f15b">&#9670;&nbsp;</a></span>visible_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string layr::visible_key = &quot;visible&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visible fully connected layer label. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
