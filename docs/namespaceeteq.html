<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tenncor: eteq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tenncor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">eteq Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceeteq_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_any_convr.html">AnyConvr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of optimization converter that represents any node.  <a href="structeteq_1_1_any_convr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_builder_arg.html">BuilderArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structeteq_1_1_func_arg.html" title="Eigen node version of teq::FuncArg. ">FuncArg</a> equivalent for optimizer's IR of functor.  <a href="structeteq_1_1_builder_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_constant.html">Constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structeteq_1_1_constant.html" title="Constant implementation of Eigen leaf tensor. ">Constant</a> implementation of Eigen leaf tensor.  <a href="structeteq_1_1_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_constant_node.html">ConstantNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structeteq_1_1_constant.html" title="Constant implementation of Eigen leaf tensor. ">Constant</a>'s node wrapper.  <a href="structeteq_1_1_constant_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_converter_builder.html">ConverterBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization builder's implementation for building ETEQ nodes.  <a href="structeteq_1_1_converter_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_coord_map.html">CoordMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen transformation wrapper implementation of iCoordMap.  <a href="structeteq_1_1_coord_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_e_a_d_loader.html">EADLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PBM Unmarshaller implementation for loading ETEQ Nodes.  <a href="structeteq_1_1_e_a_d_loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_e_a_d_saver.html">EADSaver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PBM Marshaller implementation for saving ETEQ Nodes.  <a href="structeteq_1_1_e_a_d_saver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_eigen_mat_op.html">EigenMatOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="structeteq_1_1i_eigen.html" title="Interface of generic Eigen data wrapper. ">iEigen</a> that assigns Matrix operator to Matrix object.  <a href="structeteq_1_1_eigen_mat_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_eigen_tens_op.html">EigenTensOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="structeteq_1_1i_eigen.html" title="Interface of generic Eigen data wrapper. ">iEigen</a> that assigns Tensor operator to Tensor object.  <a href="structeteq_1_1_eigen_tens_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen node version of <a class="el" href="structteq_1_1_func_arg.html" title="Coordinate mapper and tensor pair. ">teq::FuncArg</a>.  <a href="structeteq_1_1_func_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_func_convr.html">FuncConvr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of optimization converter that represents and builds functors.  <a href="structeteq_1_1_func_convr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_functor.html">Functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structeteq_1_1_functor.html" title="Functor implementation of operable functor of Eigen operators. ">Functor</a> implementation of operable functor of Eigen operators.  <a href="structeteq_1_1_functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_functor_node.html">FunctorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structeteq_1_1_functor.html" title="Functor implementation of operable functor of Eigen operators. ">Functor</a>'s node wrapper.  <a href="structeteq_1_1_functor_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_gradient_builder.html">GradientBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ETEQ implementation of TEQ's Backward Propagation Builder.  <a href="structeteq_1_1_gradient_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_group_convr.html">GroupConvr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of optimization converter that represents and builds subgraphs of specific types.  <a href="structeteq_1_1_group_convr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1i_eigen.html">iEigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of generic Eigen data wrapper.  <a href="structeteq_1_1i_eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1i_leaf.html">iLeaf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structeteq_1_1i_leaf.html" title="iLeaf extension of TEQ iLeaf containing Eigen data objects ">iLeaf</a> extension of TEQ <a class="el" href="structeteq_1_1i_leaf.html" title="iLeaf extension of TEQ iLeaf containing Eigen data objects ">iLeaf</a> containing Eigen data objects  <a href="structeteq_1_1i_leaf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1i_node.html">iNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface node for wrapping typed tensor.  <a href="structeteq_1_1i_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1i_session.html">iSession</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structeteq_1_1_session.html">Session</a> interface that tracks and rapidly updates subgraphs.  <a href="structeteq_1_1i_session.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_node_converters.html">NodeConverters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node registry of tensor types and tensor to node function.  <a href="structeteq_1_1_node_converters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_op_arg.html">OpArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw data, shape, and transformation argument struct.  <a href="structeteq_1_1_op_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_scalar_convr.html">ScalarConvr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of optimization converter that represents and builds scalar constants.  <a href="structeteq_1_1_scalar_convr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_session.html">Session</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_shaped_arr.html">ShapedArr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shaped array wraps around a vector and shape.  <a href="structeteq_1_1_shaped_arr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaf node implementation containing mutable Eigen data.  <a href="structeteq_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeteq_1_1_variable_node.html">VariableNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structeteq_1_1_variable.html" title="Leaf node implementation containing mutable Eigen data. ">Variable</a>'s node wrapper.  <a href="structeteq_1_1_variable_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a42093a0dd087ff7c9bfd08aa4ae5d909"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a> = std::shared_ptr&lt; <a class="el" href="structeteq_1_1_coord_map.html">CoordMap</a> &gt;</td></tr>
<tr class="memdesc:a42093a0dd087ff7c9bfd08aa4ae5d909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iCoordMap smartpointer.  <a href="#a42093a0dd087ff7c9bfd08aa4ae5d909">More...</a><br /></td></tr>
<tr class="separator:a42093a0dd087ff7c9bfd08aa4ae5d909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab028e26e4e3a91f10bd0209245f905b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ab028e26e4e3a91f10bd0209245f905b5">DimensionsT</a> = std::array&lt; Eigen::Index, 8 &gt;</td></tr>
<tr class="memdesc:ab028e26e4e3a91f10bd0209245f905b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen shape.  <a href="#ab028e26e4e3a91f10bd0209245f905b5">More...</a><br /></td></tr>
<tr class="separator:ab028e26e4e3a91f10bd0209245f905b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d6a582a4ef102e755fe7bc5b58abd9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64d6a582a4ef102e755fe7bc5b58abd9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a64d6a582a4ef102e755fe7bc5b58abd9">MatrixT</a> = Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="memdesc:a64d6a582a4ef102e755fe7bc5b58abd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen Matrix.  <a href="#a64d6a582a4ef102e755fe7bc5b58abd9">More...</a><br /></td></tr>
<tr class="separator:a64d6a582a4ef102e755fe7bc5b58abd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffe1a0cf0b97de97b525ff58b8eb2c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ffe1a0cf0b97de97b525ff58b8eb2c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a> = Eigen::Map&lt; <a class="el" href="namespaceeteq.html#a64d6a582a4ef102e755fe7bc5b58abd9">MatrixT</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a6ffe1a0cf0b97de97b525ff58b8eb2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen Matrix Map (reference)  <a href="#a6ffe1a0cf0b97de97b525ff58b8eb2c3">More...</a><br /></td></tr>
<tr class="separator:a6ffe1a0cf0b97de97b525ff58b8eb2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4eca370319f13ac2e7806d12d6198a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd4eca370319f13ac2e7806d12d6198a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a> = Eigen::Tensor&lt; T, 8 &gt;</td></tr>
<tr class="memdesc:abd4eca370319f13ac2e7806d12d6198a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen Tensor.  <a href="#abd4eca370319f13ac2e7806d12d6198a">More...</a><br /></td></tr>
<tr class="separator:abd4eca370319f13ac2e7806d12d6198a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59975adcb65300c7ab67f9c96868138"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af59975adcb65300c7ab67f9c96868138"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a> = Eigen::TensorMap&lt; <a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:af59975adcb65300c7ab67f9c96868138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen Tensor Map (reference)  <a href="#af59975adcb65300c7ab67f9c96868138">More...</a><br /></td></tr>
<tr class="separator:af59975adcb65300c7ab67f9c96868138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a0396c21f260f415cb2daaea658d73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2a0396c21f260f415cb2daaea658d73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a> = std::shared_ptr&lt; <a class="el" href="structeteq_1_1i_eigen.html">iEigen</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ab2a0396c21f260f415cb2daaea658d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart point of generic Eigen data object.  <a href="#ab2a0396c21f260f415cb2daaea658d73">More...</a><br /></td></tr>
<tr class="separator:ab2a0396c21f260f415cb2daaea658d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49425c0fdf5a99ea53a38575e59893e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae49425c0fdf5a99ea53a38575e59893e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ae49425c0fdf5a99ea53a38575e59893e">ArgsT</a> = std::vector&lt; <a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ae49425c0fdf5a99ea53a38575e59893e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of typed functor arguments.  <a href="#ae49425c0fdf5a99ea53a38575e59893e">More...</a><br /></td></tr>
<tr class="separator:ae49425c0fdf5a99ea53a38575e59893e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf4dd467ba202b498f9e1e1f6a4b604"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cf4dd467ba202b498f9e1e1f6a4b604"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a> = std::shared_ptr&lt; <a class="el" href="structeteq_1_1i_node.html">iNode</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a7cf4dd467ba202b498f9e1e1f6a4b604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of node.  <a href="#a7cf4dd467ba202b498f9e1e1f6a4b604">More...</a><br /></td></tr>
<tr class="separator:a7cf4dd467ba202b498f9e1e1f6a4b604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38490d7aa9ba0664def2172818d7a9d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38490d7aa9ba0664def2172818d7a9d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a38490d7aa9ba0664def2172818d7a9d1">NodesT</a> = std::vector&lt; <a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a38490d7aa9ba0664def2172818d7a9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of nodes.  <a href="#a38490d7aa9ba0664def2172818d7a9d1">More...</a><br /></td></tr>
<tr class="separator:a38490d7aa9ba0664def2172818d7a9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb681324aec84d625075d852244c905"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecb681324aec84d625075d852244c905"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#aecb681324aec84d625075d852244c905">NodeBuilderF</a> = std::function&lt; <a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;(<a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a>)&gt;</td></tr>
<tr class="memdesc:aecb681324aec84d625075d852244c905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for building a node from tensor.  <a href="#aecb681324aec84d625075d852244c905">More...</a><br /></td></tr>
<tr class="separator:aecb681324aec84d625075d852244c905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd82836fab1e19dff45de24cc719a08"><td class="memTemplParams" colspan="2">template&lt;typename OP , size_t N, typename T &gt; </td></tr>
<tr class="memitem:aabd82836fab1e19dff45de24cc719a08"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#aabd82836fab1e19dff45de24cc719a08">ReduceOutT</a> = Eigen::TensorReductionOp&lt; OP, const std::array&lt; <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>, N &gt;, const <a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:aabd82836fab1e19dff45de24cc719a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Eigen reduction operator.  <a href="#aabd82836fab1e19dff45de24cc719a08">More...</a><br /></td></tr>
<tr class="separator:aabd82836fab1e19dff45de24cc719a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8705d63cd45eefdbac721852507a067"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ae8705d63cd45eefdbac721852507a067">BuilderArgsT</a> = std::vector&lt; <a class="el" href="structeteq_1_1_builder_arg.html">BuilderArg</a> &gt;</td></tr>
<tr class="memdesc:ae8705d63cd45eefdbac721852507a067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of <a class="el" href="structeteq_1_1_func_arg.html" title="Eigen node version of teq::FuncArg. ">FuncArg</a>.  <a href="#ae8705d63cd45eefdbac721852507a067">More...</a><br /></td></tr>
<tr class="separator:ae8705d63cd45eefdbac721852507a067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdafb54367dfa57be8c0ad216632058"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a6fdafb54367dfa57be8c0ad216632058">EngineT</a> = std::default_random_engine</td></tr>
<tr class="memdesc:a6fdafb54367dfa57be8c0ad216632058"><td class="mdescLeft">&#160;</td><td class="mdescRight">RNG engine used.  <a href="#a6fdafb54367dfa57be8c0ad216632058">More...</a><br /></td></tr>
<tr class="separator:a6fdafb54367dfa57be8c0ad216632058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac055ef11e11e121ab189cd635cab0dd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac055ef11e11e121ab189cd635cab0dd3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ac055ef11e11e121ab189cd635cab0dd3">GenF</a> = std::function&lt; T()&gt;</td></tr>
<tr class="memdesc:ac055ef11e11e121ab189cd635cab0dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns a generated number.  <a href="#ac055ef11e11e121ab189cd635cab0dd3">More...</a><br /></td></tr>
<tr class="separator:ac055ef11e11e121ab189cd635cab0dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff26b4a1ee1476b028be1a7f6da978e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ff26b4a1ee1476b028be1a7f6da978e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a> = std::shared_ptr&lt; <a class="el" href="structeteq_1_1_variable_node.html">VariableNode</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a9ff26b4a1ee1476b028be1a7f6da978e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of variable nodes to preserve assign functions.  <a href="#a9ff26b4a1ee1476b028be1a7f6da978e">More...</a><br /></td></tr>
<tr class="separator:a9ff26b4a1ee1476b028be1a7f6da978e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a928c15c6e48eea5c690d81c18af42410"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a928c15c6e48eea5c690d81c18af42410"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a928c15c6e48eea5c690d81c18af42410">make_constant_scalar</a> (T scalar, <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape)</td></tr>
<tr class="memdesc:a928c15c6e48eea5c690d81c18af42410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant node given scalar and shape.  <a href="#a928c15c6e48eea5c690d81c18af42410">More...</a><br /></td></tr>
<tr class="separator:a928c15c6e48eea5c690d81c18af42410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe18b6c67bf8c55ce93b15ab26f0a271"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe18b6c67bf8c55ce93b15ab26f0a271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#afe18b6c67bf8c55ce93b15ab26f0a271">make_constant</a> (T *data, <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape)</td></tr>
<tr class="memdesc:afe18b6c67bf8c55ce93b15ab26f0a271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return constant node given raw array and shape.  <a href="#afe18b6c67bf8c55ce93b15ab26f0a271">More...</a><br /></td></tr>
<tr class="separator:afe18b6c67bf8c55ce93b15ab26f0a271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b264b2abb73b8d1982db4d5923255bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a6b264b2abb73b8d1982db4d5923255bf">reduce</a> (std::vector&lt; <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> &gt; red_dims)</td></tr>
<tr class="memdesc:a6b264b2abb73b8d1982db4d5923255bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="structeteq_1_1_coord_map.html" title="Eigen transformation wrapper implementation of iCoordMap. ">CoordMap</a> wrapper of reduction dimensions.  <a href="#a6b264b2abb73b8d1982db4d5923255bf">More...</a><br /></td></tr>
<tr class="separator:a6b264b2abb73b8d1982db4d5923255bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05388f8eb6242991c5352a6b39ce46ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a05388f8eb6242991c5352a6b39ce46ad">extend</a> (<a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> rank, std::vector&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt; ext)</td></tr>
<tr class="memdesc:a05388f8eb6242991c5352a6b39ce46ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="structeteq_1_1_coord_map.html" title="Eigen transformation wrapper implementation of iCoordMap. ">CoordMap</a> wrapper of extension parameters.  <a href="#a05388f8eb6242991c5352a6b39ce46ad">More...</a><br /></td></tr>
<tr class="separator:a05388f8eb6242991c5352a6b39ce46ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aedb407e3db6dd9e4c1195f2d3175b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a34aedb407e3db6dd9e4c1195f2d3175b">permute</a> (std::vector&lt; <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> &gt; dims)</td></tr>
<tr class="memdesc:a34aedb407e3db6dd9e4c1195f2d3175b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="structeteq_1_1_coord_map.html" title="Eigen transformation wrapper implementation of iCoordMap. ">CoordMap</a> wrapper of permute indices.  <a href="#a34aedb407e3db6dd9e4c1195f2d3175b">More...</a><br /></td></tr>
<tr class="separator:a34aedb407e3db6dd9e4c1195f2d3175b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a141d7d02c57407656ab4bc7b6a6f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49a141d7d02c57407656ab4bc7b6a6f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a49a141d7d02c57407656ab4bc7b6a6f9">tens_to_matmap</a> (<a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt; T &gt; &amp;tens)</td></tr>
<tr class="memdesc:a49a141d7d02c57407656ab4bc7b6a6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Matrix Map given Tensor.  <a href="#a49a141d7d02c57407656ab4bc7b6a6f9">More...</a><br /></td></tr>
<tr class="separator:a49a141d7d02c57407656ab4bc7b6a6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c6054f6b8792517857298e30ba214e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0c6054f6b8792517857298e30ba214e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ae0c6054f6b8792517857298e30ba214e">mat_to_matmap</a> (<a class="el" href="namespaceeteq.html#a64d6a582a4ef102e755fe7bc5b58abd9">MatrixT</a>&lt; T &gt; &amp;mat)</td></tr>
<tr class="memdesc:ae0c6054f6b8792517857298e30ba214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Map of Matrix.  <a href="#ae0c6054f6b8792517857298e30ba214e">More...</a><br /></td></tr>
<tr class="separator:ae0c6054f6b8792517857298e30ba214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab496daeef76da866e36c72ed0d6beacf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab496daeef76da866e36c72ed0d6beacf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ab496daeef76da866e36c72ed0d6beacf">tensmap_to_matmap</a> (<a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt; T &gt; &amp;tens)</td></tr>
<tr class="memdesc:ab496daeef76da866e36c72ed0d6beacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Matrix Map of Tensor Map.  <a href="#ab496daeef76da866e36c72ed0d6beacf">More...</a><br /></td></tr>
<tr class="separator:ab496daeef76da866e36c72ed0d6beacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f4b5bcfa625550a4b657a87a2f984a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8f4b5bcfa625550a4b657a87a2f984a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ae8f4b5bcfa625550a4b657a87a2f984a">mat_to_tensmap</a> (<a class="el" href="namespaceeteq.html#a64d6a582a4ef102e755fe7bc5b58abd9">MatrixT</a>&lt; T &gt; &amp;mat)</td></tr>
<tr class="memdesc:ae8f4b5bcfa625550a4b657a87a2f984a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Tensor Map of Matrix.  <a href="#ae8f4b5bcfa625550a4b657a87a2f984a">More...</a><br /></td></tr>
<tr class="separator:ae8f4b5bcfa625550a4b657a87a2f984a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7e828b7aaad974bd98fbbda1f275b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c7e828b7aaad974bd98fbbda1f275b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a6c7e828b7aaad974bd98fbbda1f275b2">tens_to_tensmap</a> (<a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt; T &gt; &amp;tens)</td></tr>
<tr class="memdesc:a6c7e828b7aaad974bd98fbbda1f275b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Tensor Map of Tensor.  <a href="#a6c7e828b7aaad974bd98fbbda1f275b2">More...</a><br /></td></tr>
<tr class="separator:a6c7e828b7aaad974bd98fbbda1f275b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bd7ebc0c8ba559211a18e5b80d8650"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EigenSource , typename EigenArgs &gt; </td></tr>
<tr class="memitem:ac9bd7ebc0c8ba559211a18e5b80d8650"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ac9bd7ebc0c8ba559211a18e5b80d8650">make_eigentensor</a> (<a class="el" href="namespaceeteq.html#ab028e26e4e3a91f10bd0209245f905b5">DimensionsT</a> dims, std::function&lt; EigenSource(EigenArgs &amp;)&gt; make_base, EigenArgs args)</td></tr>
<tr class="separator:ac9bd7ebc0c8ba559211a18e5b80d8650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47165546a605a0d78280740b2a565251"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EigenSource , typename EigenArgs &gt; </td></tr>
<tr class="memitem:a47165546a605a0d78280740b2a565251"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a47165546a605a0d78280740b2a565251">make_eigenmatrix</a> (<a class="el" href="namespaceeteq.html#ab028e26e4e3a91f10bd0209245f905b5">DimensionsT</a> dims, std::function&lt; EigenSource(EigenArgs &amp;)&gt; make_base, EigenArgs args)</td></tr>
<tr class="separator:a47165546a605a0d78280740b2a565251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec2b28b2297b50e229fec5318fa80fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ec2b28b2297b50e229fec5318fa80fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a9ec2b28b2297b50e229fec5318fa80fc">make_tensor</a> (const <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:a9ec2b28b2297b50e229fec5318fa80fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen Tensor filled with 0s given teq Shape.  <a href="#a9ec2b28b2297b50e229fec5318fa80fc">More...</a><br /></td></tr>
<tr class="separator:a9ec2b28b2297b50e229fec5318fa80fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0a4f8b1e08c01cc60582e1568f1f3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d0a4f8b1e08c01cc60582e1568f1f3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a6d0a4f8b1e08c01cc60582e1568f1f3f">make_matmap</a> (T *data, const <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:a6d0a4f8b1e08c01cc60582e1568f1f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen Matrix given raw data and teq Shape.  <a href="#a6d0a4f8b1e08c01cc60582e1568f1f3f">More...</a><br /></td></tr>
<tr class="separator:a6d0a4f8b1e08c01cc60582e1568f1f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab688a9c546afa58a03594716fa76760"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab688a9c546afa58a03594716fa76760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#aab688a9c546afa58a03594716fa76760">make_tensmap</a> (T *data, const <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:aab688a9c546afa58a03594716fa76760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen Tensor given raw data and teq Shape.  <a href="#aab688a9c546afa58a03594716fa76760">More...</a><br /></td></tr>
<tr class="separator:aab688a9c546afa58a03594716fa76760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fa3f52ce928bbe0f74c30c5136a5af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4fa3f52ce928bbe0f74c30c5136a5af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ae4fa3f52ce928bbe0f74c30c5136a5af">get_shape</a> (const <a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt; T &gt; &amp;tens)</td></tr>
<tr class="memdesc:ae4fa3f52ce928bbe0f74c30c5136a5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the teq Shape representation of Eigen Tensor.  <a href="#ae4fa3f52ce928bbe0f74c30c5136a5af">More...</a><br /></td></tr>
<tr class="separator:ae4fa3f52ce928bbe0f74c30c5136a5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5170d96342de96c52ac460a49cd70648"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5170d96342de96c52ac460a49cd70648"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a5170d96342de96c52ac460a49cd70648">get_shape</a> (const <a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt; T &gt; &amp;tens)</td></tr>
<tr class="memdesc:a5170d96342de96c52ac460a49cd70648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the teq Shape representation of Eigen Tensor Map.  <a href="#a5170d96342de96c52ac460a49cd70648">More...</a><br /></td></tr>
<tr class="separator:a5170d96342de96c52ac460a49cd70648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfa72b8375b02fa7d96b40efbba0a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab028e26e4e3a91f10bd0209245f905b5">DimensionsT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a7cfa72b8375b02fa7d96b40efbba0a98">shape_convert</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape)</td></tr>
<tr class="memdesc:a7cfa72b8375b02fa7d96b40efbba0a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen shape of teq Shape.  <a href="#a7cfa72b8375b02fa7d96b40efbba0a98">More...</a><br /></td></tr>
<tr class="separator:a7cfa72b8375b02fa7d96b40efbba0a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc5cb7a4108f45bbca14a07c2c8c6aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8bc5cb7a4108f45bbca14a07c2c8c6aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a8bc5cb7a4108f45bbca14a07c2c8c6aa">identity_map</a> (<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; node)</td></tr>
<tr class="memdesc:a8bc5cb7a4108f45bbca14a07c2c8c6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return FuncArg&lt;T&gt; that identity maps input tensor.  <a href="#a8bc5cb7a4108f45bbca14a07c2c8c6aa">More...</a><br /></td></tr>
<tr class="separator:a8bc5cb7a4108f45bbca14a07c2c8c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebc0f7d2414e751afc521a8b6165e14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaebc0f7d2414e751afc521a8b6165e14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#aaebc0f7d2414e751afc521a8b6165e14">reduce_map</a> (<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; node, <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> offset, <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> ndims)</td></tr>
<tr class="separator:aaebc0f7d2414e751afc521a8b6165e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1435fc591573994a34574c76fdfdd9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c1435fc591573994a34574c76fdfdd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a3c1435fc591573994a34574c76fdfdd9">extend_map</a> (<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; node, <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> rank, std::vector&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt; ext)</td></tr>
<tr class="separator:a3c1435fc591573994a34574c76fdfdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f6edf0a50ed2bea142af1af8034871"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05f6edf0a50ed2bea142af1af8034871"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a05f6edf0a50ed2bea142af1af8034871">permute_map</a> (<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; node, std::vector&lt; <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> &gt; order)</td></tr>
<tr class="separator:a05f6edf0a50ed2bea142af1af8034871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660502175f2bafe3baa33ea16216bc20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a660502175f2bafe3baa33ea16216bc20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a660502175f2bafe3baa33ea16216bc20">slice_map</a> (<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; node, <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> offset, <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> extent, <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> dimension)</td></tr>
<tr class="separator:a660502175f2bafe3baa33ea16216bc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9ea7d77ece833b813f27cc66921ff6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d9ea7d77ece833b813f27cc66921ff6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a0d9ea7d77ece833b813f27cc66921ff6">pad_map</a> (<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; node, const std::pair&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a>, <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt; &amp;padding, <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> dimension)</td></tr>
<tr class="separator:a0d9ea7d77ece833b813f27cc66921ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0077fdbe436d51a839a64d34b129ddf5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0077fdbe436d51a839a64d34b129ddf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a0077fdbe436d51a839a64d34b129ddf5">stride_map</a> (<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; node, const std::vector&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt; &amp;incrs)</td></tr>
<tr class="separator:a0077fdbe436d51a839a64d34b129ddf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf1f3ff5aa2fdd8c871622a2fb6826b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5cf1f3ff5aa2fdd8c871622a2fb6826b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a5cf1f3ff5aa2fdd8c871622a2fb6826b">make_functor</a> (<a class="el" href="structteq_1_1_opcode.html">teq::Opcode</a> opcode, <a class="el" href="namespaceeteq.html#ae49425c0fdf5a99ea53a38575e59893e">ArgsT</a>&lt; T &gt; args)</td></tr>
<tr class="memdesc:a5cf1f3ff5aa2fdd8c871622a2fb6826b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return functor node given opcode and node arguments.  <a href="#a5cf1f3ff5aa2fdd8c871622a2fb6826b">More...</a><br /></td></tr>
<tr class="separator:a5cf1f3ff5aa2fdd8c871622a2fb6826b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae881b98f63d9d39dacfd2a55e09b4000"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae881b98f63d9d39dacfd2a55e09b4000"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ae881b98f63d9d39dacfd2a55e09b4000">reduce_grad</a> (const <a class="el" href="structteq_1_1_func_arg.html">teq::FuncArg</a> &amp;child, <a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; bwd, size_t idx)</td></tr>
<tr class="memdesc:ae881b98f63d9d39dacfd2a55e09b4000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reduction operator gradient of reduced functor node (bwd)  <a href="#ae881b98f63d9d39dacfd2a55e09b4000">More...</a><br /></td></tr>
<tr class="separator:ae881b98f63d9d39dacfd2a55e09b4000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef512fab11d10f8cdcd332158aa236f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ef512fab11d10f8cdcd332158aa236f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a5ef512fab11d10f8cdcd332158aa236f">permute_grad</a> (<a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *fwd, <a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; bwd, size_t idx)</td></tr>
<tr class="memdesc:a5ef512fab11d10f8cdcd332158aa236f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return permutation gradient of permuted functor node (bwd)  <a href="#a5ef512fab11d10f8cdcd332158aa236f">More...</a><br /></td></tr>
<tr class="separator:a5ef512fab11d10f8cdcd332158aa236f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3358c6312e36466c027310168dd72a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab3358c6312e36466c027310168dd72a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#aab3358c6312e36466c027310168dd72a">extend_grad</a> (<a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *fwd, <a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; bwd, size_t idx)</td></tr>
<tr class="memdesc:aab3358c6312e36466c027310168dd72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return extension gradient of extended functor node (bwd)  <a href="#aab3358c6312e36466c027310168dd72a">More...</a><br /></td></tr>
<tr class="separator:aab3358c6312e36466c027310168dd72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62753ea29e5edddcdf7d153e33810d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e62753ea29e5edddcdf7d153e33810d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a6e62753ea29e5edddcdf7d153e33810d">derive</a> (<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; root, <a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt; target)</td></tr>
<tr class="memdesc:a6e62753ea29e5edddcdf7d153e33810d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive root with respect to target and optimized.  <a href="#a6e62753ea29e5edddcdf7d153e33810d">More...</a><br /></td></tr>
<tr class="separator:a6e62753ea29e5edddcdf7d153e33810d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb26a93ab74ad3d485fad18039c49169"><td class="memTemplParams" colspan="2">template&lt;typename TensType , typename T &gt; </td></tr>
<tr class="memitem:aeb26a93ab74ad3d485fad18039c49169"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#aeb26a93ab74ad3d485fad18039c49169">register_builder</a> (<a class="el" href="namespaceeteq.html#aecb681324aec84d625075d852244c905">NodeBuilderF</a>&lt; T &gt; builder)</td></tr>
<tr class="separator:aeb26a93ab74ad3d485fad18039c49169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc899d75c7ee0e1c05ee6f5c5dc90b2a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#acc899d75c7ee0e1c05ee6f5c5dc90b2a">is_2d</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape)</td></tr>
<tr class="separator:acc899d75c7ee0e1c05ee6f5c5dc90b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420dcd2896f809cd6aebc3de604ba5e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac420dcd2896f809cd6aebc3de604ba5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ac420dcd2896f809cd6aebc3de604ba5e">reduce_sum</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in) template&lt; typename T &gt; <a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt; reduce_prod(teq</td></tr>
<tr class="memdesc:ac420dcd2896f809cd6aebc3de604ba5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen data object representing reduction where aggregation is sum.  <a href="#ac420dcd2896f809cd6aebc3de604ba5e">More...</a><br /></td></tr>
<tr class="separator:ac420dcd2896f809cd6aebc3de604ba5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc7257e5e12cf3abfb27b44e7f2fa0f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0cc7257e5e12cf3abfb27b44e7f2fa0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a0cc7257e5e12cf3abfb27b44e7f2fa0f">permute</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="memdesc:a0cc7257e5e12cf3abfb27b44e7f2fa0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen data object representing transpose and permutation.  <a href="#a0cc7257e5e12cf3abfb27b44e7f2fa0f">More...</a><br /></td></tr>
<tr class="separator:a0cc7257e5e12cf3abfb27b44e7f2fa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f89520918c21c99beafd9f98c5e985"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4f89520918c21c99beafd9f98c5e985"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ab4f89520918c21c99beafd9f98c5e985">slice</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="memdesc:ab4f89520918c21c99beafd9f98c5e985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen data object representing data slicing of dimensions.  <a href="#ab4f89520918c21c99beafd9f98c5e985">More...</a><br /></td></tr>
<tr class="separator:ab4f89520918c21c99beafd9f98c5e985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236d86feb700308b6e2fc4168527543f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a236d86feb700308b6e2fc4168527543f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a236d86feb700308b6e2fc4168527543f">pad</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="memdesc:a236d86feb700308b6e2fc4168527543f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen data object representing data zero padding.  <a href="#a236d86feb700308b6e2fc4168527543f">More...</a><br /></td></tr>
<tr class="separator:a236d86feb700308b6e2fc4168527543f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b0e3fc21434e7a1f26a7d9367f6e89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85b0e3fc21434e7a1f26a7d9367f6e89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a85b0e3fc21434e7a1f26a7d9367f6e89">stride</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="memdesc:a85b0e3fc21434e7a1f26a7d9367f6e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Eigen data object representing strided view of in.  <a href="#a85b0e3fc21434e7a1f26a7d9367f6e89">More...</a><br /></td></tr>
<tr class="separator:a85b0e3fc21434e7a1f26a7d9367f6e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4603c77241a478045966610f848c5a88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4603c77241a478045966610f848c5a88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a4603c77241a478045966610f848c5a88">abs</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a4603c77241a478045966610f848c5a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79749558ba0976541d56fb60b7fda81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad79749558ba0976541d56fb60b7fda81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ad79749558ba0976541d56fb60b7fda81">neg</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:ad79749558ba0976541d56fb60b7fda81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4efdbb1af46e35407c894105a8d963e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4efdbb1af46e35407c894105a8d963e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ad4efdbb1af46e35407c894105a8d963e">sin</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:ad4efdbb1af46e35407c894105a8d963e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faec4490232e0e69fa997dda83ef005"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1faec4490232e0e69fa997dda83ef005"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a1faec4490232e0e69fa997dda83ef005">cos</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a1faec4490232e0e69fa997dda83ef005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f40c47a561f072304a2ca150b719e52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f40c47a561f072304a2ca150b719e52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a8f40c47a561f072304a2ca150b719e52">tan</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a8f40c47a561f072304a2ca150b719e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188a009044fffcdcded8837f437f5b21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a188a009044fffcdcded8837f437f5b21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a188a009044fffcdcded8837f437f5b21">exp</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a188a009044fffcdcded8837f437f5b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aece1181dda6bf97121af612832db57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8aece1181dda6bf97121af612832db57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a8aece1181dda6bf97121af612832db57">log</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a8aece1181dda6bf97121af612832db57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c675bd5f09ca0c834302e5dd17e4f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56c675bd5f09ca0c834302e5dd17e4f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a56c675bd5f09ca0c834302e5dd17e4f5">sqrt</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a56c675bd5f09ca0c834302e5dd17e4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf4296297d46496c57baf7a8d20afae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaf4296297d46496c57baf7a8d20afae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#aeaf4296297d46496c57baf7a8d20afae">round</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:aeaf4296297d46496c57baf7a8d20afae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3dbe73b46a9371a8dfa5b441974cad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add3dbe73b46a9371a8dfa5b441974cad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#add3dbe73b46a9371a8dfa5b441974cad">sigmoid</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:add3dbe73b46a9371a8dfa5b441974cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6757b448eaac15a3741f0cbb9ac7191"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6757b448eaac15a3741f0cbb9ac7191"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ac6757b448eaac15a3741f0cbb9ac7191">sigmoid_grad</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:ac6757b448eaac15a3741f0cbb9ac7191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3bf823a206ee44aa0969912f906fe6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf3bf823a206ee44aa0969912f906fe6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#acf3bf823a206ee44aa0969912f906fe6">tanh</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:acf3bf823a206ee44aa0969912f906fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e00fb08325155b25214761433b6e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a892e00fb08325155b25214761433b6e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a892e00fb08325155b25214761433b6e5">square</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a892e00fb08325155b25214761433b6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c2aa06d66fdda5833a976678e70f43"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71c2aa06d66fdda5833a976678e70f43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a71c2aa06d66fdda5833a976678e70f43">cube</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;in)</td></tr>
<tr class="separator:a71c2aa06d66fdda5833a976678e70f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb1c5706f8516219aeca650890fa644"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fb1c5706f8516219aeca650890fa644"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a7fb1c5706f8516219aeca650890fa644">pow</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a7fb1c5706f8516219aeca650890fa644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960046c66ccf66fd42b97e7cba2e7362"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a960046c66ccf66fd42b97e7cba2e7362"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a960046c66ccf66fd42b97e7cba2e7362">add</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a960046c66ccf66fd42b97e7cba2e7362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d04eba41bf31b42d691a9b8085a8c73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d04eba41bf31b42d691a9b8085a8c73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a9d04eba41bf31b42d691a9b8085a8c73">sub</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a9d04eba41bf31b42d691a9b8085a8c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad048da3634b3e31e367b88cc83e5af55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad048da3634b3e31e367b88cc83e5af55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ad048da3634b3e31e367b88cc83e5af55">mul</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ad048da3634b3e31e367b88cc83e5af55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8822763f39caf05bdf80cf20b8ea0363"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8822763f39caf05bdf80cf20b8ea0363"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a8822763f39caf05bdf80cf20b8ea0363">div</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a8822763f39caf05bdf80cf20b8ea0363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599867f3ca6cae032f134adf7fdd1357"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a599867f3ca6cae032f134adf7fdd1357"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a599867f3ca6cae032f134adf7fdd1357">eq</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a599867f3ca6cae032f134adf7fdd1357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae989be5a2ff3e8a2e3b2ac46fac1a433"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae989be5a2ff3e8a2e3b2ac46fac1a433"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ae989be5a2ff3e8a2e3b2ac46fac1a433">neq</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ae989be5a2ff3e8a2e3b2ac46fac1a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3cc8fb08f330e1bf596c2917702c01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c3cc8fb08f330e1bf596c2917702c01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a5c3cc8fb08f330e1bf596c2917702c01">lt</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a5c3cc8fb08f330e1bf596c2917702c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4639abb9c35f8e777b564e3feccc8f8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4639abb9c35f8e777b564e3feccc8f8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a4639abb9c35f8e777b564e3feccc8f8f">gt</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a4639abb9c35f8e777b564e3feccc8f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534462dc17b7a58a14bcbc0f4336438e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a534462dc17b7a58a14bcbc0f4336438e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a534462dc17b7a58a14bcbc0f4336438e">min</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a534462dc17b7a58a14bcbc0f4336438e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d501ff5b691b2daa097bb34885e671"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12d501ff5b691b2daa097bb34885e671"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a12d501ff5b691b2daa097bb34885e671">max</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a12d501ff5b691b2daa097bb34885e671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6761a4e37702b81df65dee747b53f4dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6761a4e37702b81df65dee747b53f4dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a6761a4e37702b81df65dee747b53f4dd">rand_uniform</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:a6761a4e37702b81df65dee747b53f4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac893bd9226076e55173ce37005ba1c2b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac893bd9226076e55173ce37005ba1c2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ac893bd9226076e55173ce37005ba1c2b">select</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;condition, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;then, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;otherwise)</td></tr>
<tr class="separator:ac893bd9226076e55173ce37005ba1c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83165cdabfa9ff3aef0da6c14d43301"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad83165cdabfa9ff3aef0da6c14d43301"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ad83165cdabfa9ff3aef0da6c14d43301">matmul</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;a, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ad83165cdabfa9ff3aef0da6c14d43301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c5a2a4d18c959507b0bec8f7cf52be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84c5a2a4d18c959507b0bec8f7cf52be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a84c5a2a4d18c959507b0bec8f7cf52be">convolution</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;outshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;input, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;kernel)</td></tr>
<tr class="memdesc:a84c5a2a4d18c959507b0bec8f7cf52be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply convolution of kernel across input.  <a href="#a84c5a2a4d18c959507b0bec8f7cf52be">More...</a><br /></td></tr>
<tr class="separator:a84c5a2a4d18c959507b0bec8f7cf52be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbf2efb438226db80d4c7688f82291a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fbf2efb438226db80d4c7688f82291a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a1fbf2efb438226db80d4c7688f82291a">convolution_image_grad</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;imageshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;kernel, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;super_composite)</td></tr>
<tr class="memdesc:a1fbf2efb438226db80d4c7688f82291a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the gradient of convolution with respect to image.  <a href="#a1fbf2efb438226db80d4c7688f82291a">More...</a><br /></td></tr>
<tr class="separator:a1fbf2efb438226db80d4c7688f82291a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e15b80e734e1e65c00375fdef2d28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57e15b80e734e1e65c00375fdef2d28a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a57e15b80e734e1e65c00375fdef2d28a">convolution_kernel_grad</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;kernelshape, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;image, const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;super_composite)</td></tr>
<tr class="memdesc:a57e15b80e734e1e65c00375fdef2d28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the gradient of convolution with respect to kernel.  <a href="#a57e15b80e734e1e65c00375fdef2d28a">More...</a><br /></td></tr>
<tr class="separator:a57e15b80e734e1e65c00375fdef2d28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c2565bb3f716999e7accf5e01c8162"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a54c2565bb3f716999e7accf5e01c8162">vectorize</a> (::<a class="el" href="struct_num_list.html">NumList</a> *list)</td></tr>
<tr class="separator:a54c2565bb3f716999e7accf5e01c8162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d57978912e96074a48d0f02b793c56b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a5d57978912e96074a48d0f02b793c56b">coorderize</a> (::<a class="el" href="struct_num_list.html">NumList</a> *list)</td></tr>
<tr class="separator:a5d57978912e96074a48d0f02b793c56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b213b064d0666818d6bf1032793a410"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b213b064d0666818d6bf1032793a410"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopt_1_1_opt_ctx.html">opt::OptCtx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a3b213b064d0666818d6bf1032793a410">parse</a> (std::string content)</td></tr>
<tr class="memdesc:a3b213b064d0666818d6bf1032793a410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return optimization rules tied to ETEQ Builder specified in content.  <a href="#a3b213b064d0666818d6bf1032793a410">More...</a><br /></td></tr>
<tr class="separator:a3b213b064d0666818d6bf1032793a410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21df38c5192a494cd98aee08267922cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21df38c5192a494cd98aee08267922cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structopt_1_1_opt_ctx.html">opt::OptCtx</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a21df38c5192a494cd98aee08267922cd">parse_file</a> (std::string filename)</td></tr>
<tr class="memdesc:a21df38c5192a494cd98aee08267922cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return optimization rules tied to ETEQ Builder specified in file.  <a href="#a21df38c5192a494cd98aee08267922cd">More...</a><br /></td></tr>
<tr class="separator:a21df38c5192a494cd98aee08267922cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c858b2c70bd156b376eea7e1bade394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a6fdafb54367dfa57be8c0ad216632058">EngineT</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a9c858b2c70bd156b376eea7e1bade394">get_engine</a> (void)</td></tr>
<tr class="memdesc:a9c858b2c70bd156b376eea7e1bade394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return global random generator.  <a href="#a9c858b2c70bd156b376eea7e1bade394">More...</a><br /></td></tr>
<tr class="separator:a9c858b2c70bd156b376eea7e1bade394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fccded5eea5d034ac94fe57682688aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9fccded5eea5d034ac94fe57682688aa"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a9fccded5eea5d034ac94fe57682688aa">unif</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a9fccded5eea5d034ac94fe57682688aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return uniformly generated number between a and b (integers only)  <a href="#a9fccded5eea5d034ac94fe57682688aa">More...</a><br /></td></tr>
<tr class="separator:a9fccded5eea5d034ac94fe57682688aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8b50b7cbc9312c5e765104e4efa3fd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0c8b50b7cbc9312c5e765104e4efa3fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ac055ef11e11e121ab189cd635cab0dd3">GenF</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a0c8b50b7cbc9312c5e765104e4efa3fd">unif_gen</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a0c8b50b7cbc9312c5e765104e4efa3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return uniformly generator function that produces numbers between a and b (integers only)  <a href="#a0c8b50b7cbc9312c5e765104e4efa3fd">More...</a><br /></td></tr>
<tr class="separator:a0c8b50b7cbc9312c5e765104e4efa3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cd410000decc78b01d87352accf627"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_integral&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab3cd410000decc78b01d87352accf627"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ac055ef11e11e121ab189cd635cab0dd3">GenF</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ab3cd410000decc78b01d87352accf627">unif_gen</a> (T a, T b)</td></tr>
<tr class="memdesc:ab3cd410000decc78b01d87352accf627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return uniformly generator function that produces numbers between a and b (decimals only)  <a href="#ab3cd410000decc78b01d87352accf627">More...</a><br /></td></tr>
<tr class="separator:ab3cd410000decc78b01d87352accf627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507473e79f0683738b791c4e70ed1287"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_integral&lt; T &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a507473e79f0683738b791c4e70ed1287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#ac055ef11e11e121ab189cd635cab0dd3">GenF</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a507473e79f0683738b791c4e70ed1287">norm_gen</a> (T mean, T stdev)</td></tr>
<tr class="memdesc:a507473e79f0683738b791c4e70ed1287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return normally generator function that produces numbers with mean and stdev (decimals only)  <a href="#a507473e79f0683738b791c4e70ed1287">More...</a><br /></td></tr>
<tr class="separator:a507473e79f0683738b791c4e70ed1287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8cdd34685970d0515c732871417947"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#adb8cdd34685970d0515c732871417947">is_big_endian</a> (void)</td></tr>
<tr class="separator:adb8cdd34685970d0515c732871417947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8df09a1ded310b3a30109083d40edd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c8df09a1ded310b3a30109083d40edd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a5c8df09a1ded310b3a30109083d40edd">convert_to_node</a> (<a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a>&lt; T &gt; var)</td></tr>
<tr class="memdesc:a5c8df09a1ded310b3a30109083d40edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Node smart pointer of <a class="el" href="structeteq_1_1_variable.html" title="Leaf node implementation containing mutable Eigen data. ">Variable</a> smart pointer.  <a href="#a5c8df09a1ded310b3a30109083d40edd">More...</a><br /></td></tr>
<tr class="separator:a5c8df09a1ded310b3a30109083d40edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fec0a67aeed8ca22f6591c1edb1b86"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15fec0a67aeed8ca22f6591c1edb1b86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a15fec0a67aeed8ca22f6591c1edb1b86">make_variable_scalar</a> (T scalar, <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape, std::string label=&quot;&quot;)</td></tr>
<tr class="memdesc:a15fec0a67aeed8ca22f6591c1edb1b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return variable node given scalar and shape.  <a href="#a15fec0a67aeed8ca22f6591c1edb1b86">More...</a><br /></td></tr>
<tr class="separator:a15fec0a67aeed8ca22f6591c1edb1b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bb2bb6c7afc195fa53f5d7ef0a1fd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6bb2bb6c7afc195fa53f5d7ef0a1fd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#ae6bb2bb6c7afc195fa53f5d7ef0a1fd3">make_variable</a> (<a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape, std::string label=&quot;&quot;)</td></tr>
<tr class="memdesc:ae6bb2bb6c7afc195fa53f5d7ef0a1fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return zero-initialized variable node of specified shape.  <a href="#ae6bb2bb6c7afc195fa53f5d7ef0a1fd3">More...</a><br /></td></tr>
<tr class="separator:ae6bb2bb6c7afc195fa53f5d7ef0a1fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63a34a9c90106dd1d862c375e825350"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af63a34a9c90106dd1d862c375e825350"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#af63a34a9c90106dd1d862c375e825350">make_variable</a> (T *data, <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> shape, std::string label=&quot;&quot;)</td></tr>
<tr class="memdesc:af63a34a9c90106dd1d862c375e825350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return variable node given raw array and shape.  <a href="#af63a34a9c90106dd1d862c375e825350">More...</a><br /></td></tr>
<tr class="separator:af63a34a9c90106dd1d862c375e825350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a74a3a0aa221e0af9dcb2854983ce0eb4"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a74a3a0aa221e0af9dcb2854983ce0eb4">label_limit</a> = 5</td></tr>
<tr class="separator:a74a3a0aa221e0af9dcb2854983ce0eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434aaf29f08aec14f405c428481195b3"><td class="memItemLeft" align="right" valign="top">static std::unordered_set&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeteq.html#a434aaf29f08aec14f405c428481195b3">non_bijectives</a></td></tr>
<tr class="separator:a434aaf29f08aec14f405c428481195b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="constant_8hpp.html">constant.hpp</a> eteq</p>
<p>Purpose: Implement constant leaf tensor</p>
<p>coord.hpp eteq</p>
<p>Purpose: Define Eigen transformation argument wrapper</p>
<p><a class="el" href="eigen_8hpp.html">eigen.hpp</a> eteq</p>
<p>Purpose: Define Eigen tensor and matrix transformation functions</p>
<p>funcarg.hpp eteq</p>
<p>Purpose: Typed Eigen node version of <a class="el" href="structteq_1_1_func_arg.html" title="Coordinate mapper and tensor pair. ">teq::FuncArg</a></p>
<p>functor.hpp eteq</p>
<p>Purpose: Eigen functor implementation of operable func</p>
<p><a class="el" href="grader_8hpp.html">grader.hpp</a> eteq</p>
<p>Purpose: Implement eteq gradient definition for supported operations</p>
<p>ileaf.hpp eteq</p>
<p>Purpose: Define interfaces and building blocks for an equation graph</p>
<p><a class="el" href="inode_8hpp.html">inode.hpp</a> eteq</p>
<p>Purpose: Define node interface and registration and conversion objects</p>
<p><a class="el" href="operator_8hpp.html">operator.hpp</a> eteq</p>
<p>Purpose: Define functions manipulating tensor data values No function in this file makes any attempt to check for nullptrs</p>
<p>parse.hpp eteq</p>
<p>Purpose: Extend optimization module by defining ETEQ node parsing</p>
<p><a class="el" href="random_8hpp.html">random.hpp</a> eteq</p>
<p>Purpose: Define randomization functions used in Eigen operators</p>
<p><a class="el" href="serialize_8hpp.html">serialize.hpp</a> eteq</p>
<p>Purpose: Define functions for marshal and unmarshal data sources</p>
<p>session.hpp eteq</p>
<p>Purpose: Define and implement session that tracks subgraphs and rapidly updates the tracked graph or a portion of tracked graph</p>
<p><a class="el" href="shaped__arr_8hpp.html">shaped_arr.hpp</a> eteq</p>
<p>Purpose: Define a data-shape representation to feed in to the variable</p>
<p><a class="el" href="variable_8hpp.html">variable.hpp</a> eteq</p>
<p>Purpose: Define data structures for owning, and passing generalized and type-specific data </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae49425c0fdf5a99ea53a38575e59893e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49425c0fdf5a99ea53a38575e59893e">&#9670;&nbsp;</a></span>ArgsT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#ae49425c0fdf5a99ea53a38575e59893e">eteq::ArgsT</a> = typedef std::vector&lt;<a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of typed functor arguments. </p>

</div>
</div>
<a id="ae8705d63cd45eefdbac721852507a067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8705d63cd45eefdbac721852507a067">&#9670;&nbsp;</a></span>BuilderArgsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#ae8705d63cd45eefdbac721852507a067">eteq::BuilderArgsT</a> = typedef std::vector&lt;<a class="el" href="structeteq_1_1_builder_arg.html">BuilderArg</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of <a class="el" href="structeteq_1_1_func_arg.html" title="Eigen node version of teq::FuncArg. ">FuncArg</a>. </p>

</div>
</div>
<a id="a42093a0dd087ff7c9bfd08aa4ae5d909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42093a0dd087ff7c9bfd08aa4ae5d909">&#9670;&nbsp;</a></span>CoordptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">eteq::CoordptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structeteq_1_1_coord_map.html">CoordMap</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of iCoordMap smartpointer. </p>

</div>
</div>
<a id="ab028e26e4e3a91f10bd0209245f905b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab028e26e4e3a91f10bd0209245f905b5">&#9670;&nbsp;</a></span>DimensionsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#ab028e26e4e3a91f10bd0209245f905b5">eteq::DimensionsT</a> = typedef std::array&lt;Eigen::Index,8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen shape. </p>

</div>
</div>
<a id="ab2a0396c21f260f415cb2daaea658d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a0396c21f260f415cb2daaea658d73">&#9670;&nbsp;</a></span>EigenptrT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">eteq::EigenptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structeteq_1_1i_eigen.html">iEigen</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart point of generic Eigen data object. </p>

</div>
</div>
<a id="a6fdafb54367dfa57be8c0ad216632058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdafb54367dfa57be8c0ad216632058">&#9670;&nbsp;</a></span>EngineT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#a6fdafb54367dfa57be8c0ad216632058">eteq::EngineT</a> = typedef std::default_random_engine</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RNG engine used. </p>

</div>
</div>
<a id="ac055ef11e11e121ab189cd635cab0dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac055ef11e11e121ab189cd635cab0dd3">&#9670;&nbsp;</a></span>GenF</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#ac055ef11e11e121ab189cd635cab0dd3">eteq::GenF</a> = typedef std::function&lt;T()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that returns a generated number. </p>

</div>
</div>
<a id="a6ffe1a0cf0b97de97b525ff58b8eb2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffe1a0cf0b97de97b525ff58b8eb2c3">&#9670;&nbsp;</a></span>MatMapT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">eteq::MatMapT</a> = typedef Eigen::Map&lt;<a class="el" href="namespaceeteq.html#a64d6a582a4ef102e755fe7bc5b58abd9">MatrixT</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen Matrix Map (reference) </p>

</div>
</div>
<a id="a64d6a582a4ef102e755fe7bc5b58abd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d6a582a4ef102e755fe7bc5b58abd9">&#9670;&nbsp;</a></span>MatrixT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#a64d6a582a4ef102e755fe7bc5b58abd9">eteq::MatrixT</a> = typedef Eigen::Matrix&lt;T,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen Matrix. </p>

</div>
</div>
<a id="aecb681324aec84d625075d852244c905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb681324aec84d625075d852244c905">&#9670;&nbsp;</a></span>NodeBuilderF</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#aecb681324aec84d625075d852244c905">eteq::NodeBuilderF</a> = typedef std::function&lt;<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt;(<a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for building a node from tensor. </p>

</div>
</div>
<a id="a7cf4dd467ba202b498f9e1e1f6a4b604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf4dd467ba202b498f9e1e1f6a4b604">&#9670;&nbsp;</a></span>NodeptrT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">eteq::NodeptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structeteq_1_1i_node.html">iNode</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of node. </p>

</div>
</div>
<a id="a38490d7aa9ba0664def2172818d7a9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38490d7aa9ba0664def2172818d7a9d1">&#9670;&nbsp;</a></span>NodesT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#a38490d7aa9ba0664def2172818d7a9d1">eteq::NodesT</a> = typedef std::vector&lt;<a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of nodes. </p>

</div>
</div>
<a id="aabd82836fab1e19dff45de24cc719a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd82836fab1e19dff45de24cc719a08">&#9670;&nbsp;</a></span>ReduceOutT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OP , size_t N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#aabd82836fab1e19dff45de24cc719a08">eteq::ReduceOutT</a> = typedef Eigen::TensorReductionOp&lt;OP, const std::array&lt;<a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>,N&gt;,const <a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic Eigen reduction operator. </p>

</div>
</div>
<a id="af59975adcb65300c7ab67f9c96868138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59975adcb65300c7ab67f9c96868138">&#9670;&nbsp;</a></span>TensMapT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">eteq::TensMapT</a> = typedef Eigen::TensorMap&lt;<a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen Tensor Map (reference) </p>

</div>
</div>
<a id="abd4eca370319f13ac2e7806d12d6198a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4eca370319f13ac2e7806d12d6198a">&#9670;&nbsp;</a></span>TensorT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">eteq::TensorT</a> = typedef Eigen::Tensor&lt;T,8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen Tensor. </p>

</div>
</div>
<a id="a9ff26b4a1ee1476b028be1a7f6da978e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff26b4a1ee1476b028be1a7f6da978e">&#9670;&nbsp;</a></span>VarptrT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">eteq::VarptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structeteq_1_1_variable_node.html">VariableNode</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of variable nodes to preserve assign functions. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4603c77241a478045966610f848c5a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4603c77241a478045966610f848c5a88">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take absolute value of inputs </p>

</div>
</div>
<a id="a960046c66ccf66fd42b97e7cba2e7362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960046c66ccf66fd42b97e7cba2e7362">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c8df09a1ded310b3a30109083d40edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8df09a1ded310b3a30109083d40edd">&#9670;&nbsp;</a></span>convert_to_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; eteq::convert_to_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Node smart pointer of <a class="el" href="structeteq_1_1_variable.html" title="Leaf node implementation containing mutable Eigen data. ">Variable</a> smart pointer. </p>

</div>
</div>
<a id="a84c5a2a4d18c959507b0bec8f7cf52be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c5a2a4d18c959507b0bec8f7cf52be">&#9670;&nbsp;</a></span>convolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::convolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply convolution of kernel across input. </p>

</div>
</div>
<a id="a1fbf2efb438226db80d4c7688f82291a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbf2efb438226db80d4c7688f82291a">&#9670;&nbsp;</a></span>convolution_image_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::convolution_image_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>imageshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>super_composite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the gradient of convolution with respect to image. </p>

</div>
</div>
<a id="a57e15b80e734e1e65c00375fdef2d28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e15b80e734e1e65c00375fdef2d28a">&#9670;&nbsp;</a></span>convolution_kernel_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::convolution_kernel_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>kernelshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>super_composite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the gradient of convolution with respect to kernel. </p>

</div>
</div>
<a id="a5d57978912e96074a48d0f02b793c56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d57978912e96074a48d0f02b793c56b">&#9670;&nbsp;</a></span>coorderize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a> eteq::coorderize </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="struct_num_list.html">NumList</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1faec4490232e0e69fa997dda83ef005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faec4490232e0e69fa997dda83ef005">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take cosine of inputs </p>

</div>
</div>
<a id="a71c2aa06d66fdda5833a976678e70f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c2aa06d66fdda5833a976678e70f43">&#9670;&nbsp;</a></span>cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e62753ea29e5edddcdf7d153e33810d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e62753ea29e5edddcdf7d153e33810d">&#9670;&nbsp;</a></span>derive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; eteq::derive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derive root with respect to target and optimized. </p>

</div>
</div>
<a id="a8822763f39caf05bdf80cf20b8ea0363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8822763f39caf05bdf80cf20b8ea0363">&#9670;&nbsp;</a></span>div()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments a, and b, for every pair of mapped elements sharing the same index divide Only accept 2 arguments </p>

</div>
</div>
<a id="a599867f3ca6cae032f134adf7fdd1357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599867f3ca6cae032f134adf7fdd1357">&#9670;&nbsp;</a></span>eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments a, and b, for every pair of mapped elements sharing the same index apply == operator Only accept 2 arguments </p>

</div>
</div>
<a id="a188a009044fffcdcded8837f437f5b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188a009044fffcdcded8837f437f5b21">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take exponent of inputs </p>

</div>
</div>
<a id="a05388f8eb6242991c5352a6b39ce46ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05388f8eb6242991c5352a6b39ce46ad">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a> eteq::extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <a class="el" href="structeteq_1_1_coord_map.html" title="Eigen transformation wrapper implementation of iCoordMap. ">CoordMap</a> wrapper of extension parameters. </p>

</div>
</div>
<a id="aab3358c6312e36466c027310168dd72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3358c6312e36466c027310168dd72a">&#9670;&nbsp;</a></span>extend_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; eteq::extend_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *&#160;</td>
          <td class="paramname"><em>fwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>bwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return extension gradient of extended functor node (bwd) </p>

</div>
</div>
<a id="a3c1435fc591573994a34574c76fdfdd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1435fc591573994a34574c76fdfdd9">&#9670;&nbsp;</a></span>extend_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt;T&gt; eteq::extend_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return FuncArg&lt;T&gt; that extends input tensor by rank and extension vector E.g.: tensor w/ shape [2, 1, 1], rank = 1, ext = [3, 4] gets mapped to [2, 3, 4] </p>

</div>
</div>
<a id="a9c858b2c70bd156b376eea7e1bade394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c858b2c70bd156b376eea7e1bade394">&#9670;&nbsp;</a></span>get_engine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a6fdafb54367dfa57be8c0ad216632058">EngineT</a>&amp; eteq::get_engine </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return global random generator. </p>

</div>
</div>
<a id="ae4fa3f52ce928bbe0f74c30c5136a5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fa3f52ce928bbe0f74c30c5136a5af">&#9670;&nbsp;</a></span>get_shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> eteq::get_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the teq Shape representation of Eigen Tensor. </p>

</div>
</div>
<a id="a5170d96342de96c52ac460a49cd70648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5170d96342de96c52ac460a49cd70648">&#9670;&nbsp;</a></span>get_shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> eteq::get_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the teq Shape representation of Eigen Tensor Map. </p>

</div>
</div>
<a id="a4639abb9c35f8e777b564e3feccc8f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4639abb9c35f8e777b564e3feccc8f8f">&#9670;&nbsp;</a></span>gt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::gt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments a, and b, for every pair of mapped elements sharing the same index apply &gt; operator Only accept 2 arguments </p>

</div>
</div>
<a id="a8bc5cb7a4108f45bbca14a07c2c8c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc5cb7a4108f45bbca14a07c2c8c6aa">&#9670;&nbsp;</a></span>identity_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt;T&gt; eteq::identity_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return FuncArg&lt;T&gt; that identity maps input tensor. </p>

</div>
</div>
<a id="acc899d75c7ee0e1c05ee6f5c5dc90b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc899d75c7ee0e1c05ee6f5c5dc90b2a">&#9670;&nbsp;</a></span>is_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool eteq::is_2d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb8cdd34685970d0515c732871417947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8cdd34685970d0515c732871417947">&#9670;&nbsp;</a></span>is_big_endian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool eteq::is_big_endian </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aece1181dda6bf97121af612832db57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aece1181dda6bf97121af612832db57">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take natural log of inputs </p>

</div>
</div>
<a id="a5c3cc8fb08f330e1bf596c2917702c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3cc8fb08f330e1bf596c2917702c01">&#9670;&nbsp;</a></span>lt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments a, and b, for every pair of mapped elements sharing the same index apply &lt; operator Only accept 2 arguments </p>

</div>
</div>
<a id="afe18b6c67bf8c55ce93b15ab26f0a271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe18b6c67bf8c55ce93b15ab26f0a271">&#9670;&nbsp;</a></span>make_constant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; eteq::make_constant </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return constant node given raw array and shape. </p>

</div>
</div>
<a id="a928c15c6e48eea5c690d81c18af42410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928c15c6e48eea5c690d81c18af42410">&#9670;&nbsp;</a></span>make_constant_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; eteq::make_constant_scalar </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return constant node given scalar and shape. </p>

</div>
</div>
<a id="a47165546a605a0d78280740b2a565251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47165546a605a0d78280740b2a565251">&#9670;&nbsp;</a></span>make_eigenmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename EigenSource , typename EigenArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::make_eigenmatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#ab028e26e4e3a91f10bd0209245f905b5">DimensionsT</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; EigenSource(EigenArgs &amp;)&gt;&#160;</td>
          <td class="paramname"><em>make_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EigenArgs&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return Eigen Matrix wrapper given output shape, and Eigen operator creation and arguments </p>

</div>
</div>
<a id="ac9bd7ebc0c8ba559211a18e5b80d8650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bd7ebc0c8ba559211a18e5b80d8650">&#9670;&nbsp;</a></span>make_eigentensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename EigenSource , typename EigenArgs &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::make_eigentensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#ab028e26e4e3a91f10bd0209245f905b5">DimensionsT</a>&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; EigenSource(EigenArgs &amp;)&gt;&#160;</td>
          <td class="paramname"><em>make_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EigenArgs&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return Eigen Tensor wrapper given output shape, and Eigen operator creation and arguments </p>

</div>
</div>
<a id="a5cf1f3ff5aa2fdd8c871622a2fb6826b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf1f3ff5aa2fdd8c871622a2fb6826b">&#9670;&nbsp;</a></span>make_functor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; eteq::make_functor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_opcode.html">teq::Opcode</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#ae49425c0fdf5a99ea53a38575e59893e">ArgsT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return functor node given opcode and node arguments. </p>

</div>
</div>
<a id="a6d0a4f8b1e08c01cc60582e1568f1f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0a4f8b1e08c01cc60582e1568f1f3f">&#9670;&nbsp;</a></span>make_matmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a>&lt;T&gt; eteq::make_matmap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Eigen Matrix given raw data and teq Shape. </p>

</div>
</div>
<a id="aab688a9c546afa58a03594716fa76760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab688a9c546afa58a03594716fa76760">&#9670;&nbsp;</a></span>make_tensmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt;T&gt; eteq::make_tensmap </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Eigen Tensor given raw data and teq Shape. </p>

</div>
</div>
<a id="a9ec2b28b2297b50e229fec5318fa80fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec2b28b2297b50e229fec5318fa80fc">&#9670;&nbsp;</a></span>make_tensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt;T&gt; eteq::make_tensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Eigen Tensor filled with 0s given teq Shape. </p>

</div>
</div>
<a id="ae6bb2bb6c7afc195fa53f5d7ef0a1fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bb2bb6c7afc195fa53f5d7ef0a1fd3">&#9670;&nbsp;</a></span>make_variable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a>&lt;T&gt; eteq::make_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return zero-initialized variable node of specified shape. </p>

</div>
</div>
<a id="af63a34a9c90106dd1d862c375e825350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63a34a9c90106dd1d862c375e825350">&#9670;&nbsp;</a></span>make_variable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a>&lt;T&gt; eteq::make_variable </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return variable node given raw array and shape. </p>

</div>
</div>
<a id="a15fec0a67aeed8ca22f6591c1edb1b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fec0a67aeed8ca22f6591c1edb1b86">&#9670;&nbsp;</a></span>make_variable_scalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a9ff26b4a1ee1476b028be1a7f6da978e">VarptrT</a>&lt;T&gt; eteq::make_variable_scalar </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>label</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return variable node given scalar and shape. </p>

</div>
</div>
<a id="ae0c6054f6b8792517857298e30ba214e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c6054f6b8792517857298e30ba214e">&#9670;&nbsp;</a></span>mat_to_matmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a>&lt;T&gt; eteq::mat_to_matmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a64d6a582a4ef102e755fe7bc5b58abd9">MatrixT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Map of Matrix. </p>

</div>
</div>
<a id="ae8f4b5bcfa625550a4b657a87a2f984a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f4b5bcfa625550a4b657a87a2f984a">&#9670;&nbsp;</a></span>mat_to_tensmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt;T&gt; eteq::mat_to_tensmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a64d6a582a4ef102e755fe7bc5b58abd9">MatrixT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Tensor Map of Matrix. </p>

</div>
</div>
<a id="ad83165cdabfa9ff3aef0da6c14d43301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83165cdabfa9ff3aef0da6c14d43301">&#9670;&nbsp;</a></span>matmul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::matmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only applies to 2-d tensors Apply matrix multiplication of a and b </p>

</div>
</div>
<a id="a12d501ff5b691b2daa097bb34885e671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d501ff5b691b2daa097bb34885e671">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments, for every mapped index i in range [0:max_nelems], take the maximum all elements for all arguments </p>

</div>
</div>
<a id="a534462dc17b7a58a14bcbc0f4336438e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534462dc17b7a58a14bcbc0f4336438e">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments, for every mapped index i in range [0:max_nelems], take the minimum all elements for all arguments </p>

</div>
</div>
<a id="ad048da3634b3e31e367b88cc83e5af55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad048da3634b3e31e367b88cc83e5af55">&#9670;&nbsp;</a></span>mul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad79749558ba0976541d56fb60b7fda81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79749558ba0976541d56fb60b7fda81">&#9670;&nbsp;</a></span>neg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::neg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take negatives of inputs </p>

</div>
</div>
<a id="ae989be5a2ff3e8a2e3b2ac46fac1a433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae989be5a2ff3e8a2e3b2ac46fac1a433">&#9670;&nbsp;</a></span>neq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::neq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments a, and b, for every pair of mapped elements sharing the same index apply != operator Only accept 2 arguments </p>

</div>
</div>
<a id="a507473e79f0683738b791c4e70ed1287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507473e79f0683738b791c4e70ed1287">&#9670;&nbsp;</a></span>norm_gen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_integral&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ac055ef11e11e121ab189cd635cab0dd3">GenF</a>&lt;T&gt; eteq::norm_gen </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return normally generator function that produces numbers with mean and stdev (decimals only) </p>

</div>
</div>
<a id="a236d86feb700308b6e2fc4168527543f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236d86feb700308b6e2fc4168527543f">&#9670;&nbsp;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::pad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Eigen data object representing data zero padding. </p>

</div>
</div>
<a id="a0d9ea7d77ece833b813f27cc66921ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9ea7d77ece833b813f27cc66921ff6">&#9670;&nbsp;</a></span>pad_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt;T&gt; eteq::pad_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a>, <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return FuncArg&lt;T&gt; that pads tensor with 0s across specified dimension E.g.: tensor w/ shape [2, 3, 4], padding = {2,1}, dimension = 0 gets mapped to [5, 3, 4] where [0,:,:] and [3:5,:,:] are 0 (first, fourth, and fifth slices of the 1st dimension are 0) </p>

</div>
</div>
<a id="a3b213b064d0666818d6bf1032793a410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b213b064d0666818d6bf1032793a410">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopt_1_1_opt_ctx.html">opt::OptCtx</a> eteq::parse </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return optimization rules tied to ETEQ Builder specified in content. </p>

</div>
</div>
<a id="a21df38c5192a494cd98aee08267922cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21df38c5192a494cd98aee08267922cd">&#9670;&nbsp;</a></span>parse_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopt_1_1_opt_ctx.html">opt::OptCtx</a> eteq::parse_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return optimization rules tied to ETEQ Builder specified in file. </p>

</div>
</div>
<a id="a34aedb407e3db6dd9e4c1195f2d3175b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34aedb407e3db6dd9e4c1195f2d3175b">&#9670;&nbsp;</a></span>permute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a> eteq::permute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> &gt;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <a class="el" href="structeteq_1_1_coord_map.html" title="Eigen transformation wrapper implementation of iCoordMap. ">CoordMap</a> wrapper of permute indices. </p>

</div>
</div>
<a id="a0cc7257e5e12cf3abfb27b44e7f2fa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc7257e5e12cf3abfb27b44e7f2fa0f">&#9670;&nbsp;</a></span>permute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::permute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Eigen data object representing transpose and permutation. </p>

</div>
</div>
<a id="a5ef512fab11d10f8cdcd332158aa236f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef512fab11d10f8cdcd332158aa236f">&#9670;&nbsp;</a></span>permute_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; eteq::permute_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *&#160;</td>
          <td class="paramname"><em>fwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>bwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return permutation gradient of permuted functor node (bwd) </p>

</div>
</div>
<a id="a05f6edf0a50ed2bea142af1af8034871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f6edf0a50ed2bea142af1af8034871">&#9670;&nbsp;</a></span>permute_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt;T&gt; eteq::permute_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> &gt;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return FuncArg&lt;T&gt; that permutes input tensor by order E.g.: tensor w/ shape [2, 3, 4], order = [1, 2, 0] gets mapped to [3, 4, 2] </p>

</div>
</div>
<a id="a7fb1c5706f8516219aeca650890fa644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb1c5706f8516219aeca650890fa644">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments a, and b, for every pair of mapped elements sharing the same index apply std::pow operator Only accept 2 arguments </p>

</div>
</div>
<a id="a6761a4e37702b81df65dee747b53f4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6761a4e37702b81df65dee747b53f4dd">&#9670;&nbsp;</a></span>rand_uniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::rand_uniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments a, and b, for every pair of mapped elements sharing the same index apply std::uniform_distributon function Only accept 2 arguments </p>

</div>
</div>
<a id="a6b264b2abb73b8d1982db4d5923255bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b264b2abb73b8d1982db4d5923255bf">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a42093a0dd087ff7c9bfd08aa4ae5d909">CoordptrT</a> eteq::reduce </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a> &gt;&#160;</td>
          <td class="paramname"><em>red_dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <a class="el" href="structeteq_1_1_coord_map.html" title="Eigen transformation wrapper implementation of iCoordMap. ">CoordMap</a> wrapper of reduction dimensions. </p>

</div>
</div>
<a id="ae881b98f63d9d39dacfd2a55e09b4000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae881b98f63d9d39dacfd2a55e09b4000">&#9670;&nbsp;</a></span>reduce_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt;T&gt; eteq::reduce_grad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structteq_1_1_func_arg.html">teq::FuncArg</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>bwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return reduction operator gradient of reduced functor node (bwd) </p>

</div>
</div>
<a id="aaebc0f7d2414e751afc521a8b6165e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebc0f7d2414e751afc521a8b6165e14">&#9670;&nbsp;</a></span>reduce_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt;T&gt; eteq::reduce_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>ndims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return FuncArg&lt;T&gt; that reduces input tensor by units in reduction vector after specified rank E.g.: tensor w/ shape [2, 3, 4], offset = 1, ndims = 2 gets mapped to [2, 1, 1] </p>

</div>
</div>
<a id="ac420dcd2896f809cd6aebc3de604ba5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac420dcd2896f809cd6aebc3de604ba5e">&#9670;&nbsp;</a></span>reduce_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::reduce_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Eigen data object representing reduction where aggregation is sum. </p>
<p>Return Eigen data object representing reduction where aggregation is prod </p>

</div>
</div>
<a id="aeb26a93ab74ad3d485fad18039c49169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb26a93ab74ad3d485fad18039c49169">&#9670;&nbsp;</a></span>register_builder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensType , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool eteq::register_builder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#aecb681324aec84d625075d852244c905">NodeBuilderF</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if tensor type successfully registers and maps to node builder, otherwise false </p>

</div>
</div>
<a id="aeaf4296297d46496c57baf7a8d20afae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf4296297d46496c57baf7a8d20afae">&#9670;&nbsp;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take rounded values of inputs </p>

</div>
</div>
<a id="ac893bd9226076e55173ce37005ba1c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac893bd9226076e55173ce37005ba1c2b">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherwise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a condition, then values and otherwise apply corresponding then value if condition is non-zero otherwise apply otherwise value </p>

</div>
</div>
<a id="a7cfa72b8375b02fa7d96b40efbba0a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfa72b8375b02fa7d96b40efbba0a98">&#9670;&nbsp;</a></span>shape_convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab028e26e4e3a91f10bd0209245f905b5">DimensionsT</a> eteq::shape_convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a>&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Eigen shape of teq Shape. </p>

</div>
</div>
<a id="add3dbe73b46a9371a8dfa5b441974cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3dbe73b46a9371a8dfa5b441974cad">&#9670;&nbsp;</a></span>sigmoid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::sigmoid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6757b448eaac15a3741f0cbb9ac7191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6757b448eaac15a3741f0cbb9ac7191">&#9670;&nbsp;</a></span>sigmoid_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::sigmoid_grad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4efdbb1af46e35407c894105a8d963e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4efdbb1af46e35407c894105a8d963e">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take sine of inputs </p>

</div>
</div>
<a id="ab4f89520918c21c99beafd9f98c5e985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f89520918c21c99beafd9f98c5e985">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Eigen data object representing data slicing of dimensions. </p>

</div>
</div>
<a id="a660502175f2bafe3baa33ea16216bc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660502175f2bafe3baa33ea16216bc20">&#9670;&nbsp;</a></span>slice_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt;T&gt; eteq::slice_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#afe93437df6982cc586e6ea8ffcf1e252">teq::RankT</a>&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return FuncArg&lt;T&gt; that takes specific slice of tensor E.g.: tensor w/ shape [2, 3, 4], offset = 1, extent = 2, and dimension = 2 gets mapped to [3, 4, 2] that references [:,:,1:3] (second and third slices of the 3rd dimension) </p>

</div>
</div>
<a id="a56c675bd5f09ca0c834302e5dd17e4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c675bd5f09ca0c834302e5dd17e4f5">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take square root of inputs </p>

</div>
</div>
<a id="a892e00fb08325155b25214761433b6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892e00fb08325155b25214761433b6e5">&#9670;&nbsp;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85b0e3fc21434e7a1f26a7d9367f6e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b0e3fc21434e7a1f26a7d9367f6e89">&#9670;&nbsp;</a></span>stride()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::stride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return Eigen data object representing strided view of in. </p>

</div>
</div>
<a id="a0077fdbe436d51a839a64d34b129ddf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0077fdbe436d51a839a64d34b129ddf5">&#9670;&nbsp;</a></span>stride_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeteq_1_1_func_arg.html">FuncArg</a>&lt;T&gt; eteq::stride_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#a7cf4dd467ba202b498f9e1e1f6a4b604">NodeptrT</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceteq.html#a4a6faa1aee3a0541c128c26bcf4b6d89">teq::DimT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>incrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return FuncArg&lt;T&gt; that takes elements of specific increments across dimensions starting from 0 E.g.: tensor w/ shape [2, 3, 4], incrs = {1, 2, 2} gets mapped to [2, 2, 2] where output[:,0,0] takes on input[:,0,0] output[:,1,0] takes on input[:,2,0] output[:,0,1] takes on input[:,0,2] output[:,1,1] takes on input[:,2,2] </p>

</div>
</div>
<a id="a9d04eba41bf31b42d691a9b8085a8c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d04eba41bf31b42d691a9b8085a8c73">&#9670;&nbsp;</a></span>sub()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given arguments a, and b, for every pair of mapped elements sharing the same index subtract Only accept 2 arguments </p>

</div>
</div>
<a id="a8f40c47a561f072304a2ca150b719e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f40c47a561f072304a2ca150b719e52">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given reference to output array, and input vector ref, make output elements take tangent of inputs </p>

</div>
</div>
<a id="acf3bf823a206ee44aa0969912f906fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3bf823a206ee44aa0969912f906fe6">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ab2a0396c21f260f415cb2daaea658d73">EigenptrT</a>&lt;T&gt; eteq::tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1_shape.html">teq::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>outshape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeteq_1_1_op_arg.html">OpArg</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a141d7d02c57407656ab4bc7b6a6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a141d7d02c57407656ab4bc7b6a6f9">&#9670;&nbsp;</a></span>tens_to_matmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a>&lt;T&gt; eteq::tens_to_matmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Matrix Map given Tensor. </p>

</div>
</div>
<a id="a6c7e828b7aaad974bd98fbbda1f275b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7e828b7aaad974bd98fbbda1f275b2">&#9670;&nbsp;</a></span>tens_to_tensmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt;T&gt; eteq::tens_to_tensmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#abd4eca370319f13ac2e7806d12d6198a">TensorT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Tensor Map of Tensor. </p>

</div>
</div>
<a id="ab496daeef76da866e36c72ed0d6beacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab496daeef76da866e36c72ed0d6beacf">&#9670;&nbsp;</a></span>tensmap_to_matmap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#a6ffe1a0cf0b97de97b525ff58b8eb2c3">MatMapT</a>&lt;T&gt; eteq::tensmap_to_matmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceeteq.html#af59975adcb65300c7ab67f9c96868138">TensMapT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>tens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return Matrix Map of Tensor Map. </p>

</div>
</div>
<a id="a9fccded5eea5d034ac94fe57682688aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fccded5eea5d034ac94fe57682688aa">&#9670;&nbsp;</a></span>unif()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T eteq::unif </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return uniformly generated number between a and b (integers only) </p>
<p>Return uniformly generate number between a and b (decimals only) </p>

</div>
</div>
<a id="a0c8b50b7cbc9312c5e765104e4efa3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8b50b7cbc9312c5e765104e4efa3fd">&#9670;&nbsp;</a></span>unif_gen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ac055ef11e11e121ab189cd635cab0dd3">GenF</a>&lt;T&gt; eteq::unif_gen </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return uniformly generator function that produces numbers between a and b (integers only) </p>

</div>
</div>
<a id="ab3cd410000decc78b01d87352accf627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cd410000decc78b01d87352accf627">&#9670;&nbsp;</a></span>unif_gen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_integral&lt; T &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceeteq.html#ac055ef11e11e121ab189cd635cab0dd3">GenF</a>&lt;T&gt; eteq::unif_gen </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return uniformly generator function that produces numbers between a and b (decimals only) </p>

</div>
</div>
<a id="a54c2565bb3f716999e7accf5e01c8162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c2565bb3f716999e7accf5e01c8162">&#9670;&nbsp;</a></span>vectorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;double&gt; eteq::vectorize </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="struct_num_list.html">NumList</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a74a3a0aa221e0af9dcb2854983ce0eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a3a0aa221e0af9dcb2854983ce0eb4">&#9670;&nbsp;</a></span>label_limit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t eteq::label_limit = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a434aaf29f08aec14f405c428481195b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434aaf29f08aec14f405c428481195b3">&#9670;&nbsp;</a></span>non_bijectives</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;size_t&gt; eteq::non_bijectives</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">{</div><div class="line">    egen::REDUCE_SUM,</div><div class="line">    egen::REDUCE_PROD,</div><div class="line">    egen::REDUCE_MIN,</div><div class="line">    egen::REDUCE_MAX,</div><div class="line">    egen::EXTEND,</div><div class="line">}</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
