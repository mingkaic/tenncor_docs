<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tenncor: opt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tenncor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">opt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_cand_arg.html">CandArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulation of match output argument.  <a href="structopt_1_1_cand_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_comm_hasher.html">CommHasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash variadic/commutative arguments that ignores order.  <a href="structopt_1_1_comm_hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_comm_voter.html">CommVoter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement voter for commutative functors.  <a href="structopt_1_1_comm_voter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1i_converter.html">iConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converter interface for building TEQ graphs.  <a href="structopt_1_1i_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1i_converter_builder.html">iConverterBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for TEQ extensions to construct conversion rules.  <a href="structopt_1_1i_converter_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1i_voter.html">iVoter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rule tree node that identify and selects matching candidates.  <a href="structopt_1_1i_voter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_matcher.html">Matcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_opt_ctx.html">OptCtx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulation of all conversion rules.  <a href="structopt_1_1_opt_ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_ordr_hasher.html">OrdrHasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash voter arguments while preserving order of arguments.  <a href="structopt_1_1_ordr_hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_ordr_voter.html">OrdrVoter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement voter for ordered (non-commutative) functors.  <a href="structopt_1_1_ordr_voter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_rules_context.html">RulesContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global statements shared between all rule statements.  <a href="structopt_1_1_rules_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_seg_v_args.html">SegVArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic/communtative branch voter arguments.  <a href="structopt_1_1_seg_v_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_symbol.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic representation of a conversion rule.  <a href="structopt_1_1_symbol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_symbol_hash.html">SymbolHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hasher to encode rule key.  <a href="structopt_1_1_symbol_hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_variadic_voter.html">VariadicVoter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement voter for variadic groups.  <a href="structopt_1_1_variadic_voter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_voter_arg.html">VoterArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argument voter for functors.  <a href="structopt_1_1_voter_arg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt_1_1_voter_pool.html">VoterPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed representation of a rule tree.  <a href="structopt_1_1_voter_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8417f9778df10bf451cc044b720fa8c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a8417f9778df10bf451cc044b720fa8c5">CtxValT</a> = std::set&lt; <a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a> &gt;</td></tr>
<tr class="memdesc:a8417f9778df10bf451cc044b720fa8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of tensors that potentially matches some id.  <a href="#a8417f9778df10bf451cc044b720fa8c5">More...</a><br /></td></tr>
<tr class="separator:a8417f9778df10bf451cc044b720fa8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2b7aa7d628257aa90d3c00252fadb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aad2b7aa7d628257aa90d3c00252fadb7">ContexT</a> = std::map&lt; std::string, <a class="el" href="namespaceopt.html#a8417f9778df10bf451cc044b720fa8c5">CtxValT</a> &gt;</td></tr>
<tr class="memdesc:aad2b7aa7d628257aa90d3c00252fadb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of rule graph leaf identifiers to corresponding matches.  <a href="#aad2b7aa7d628257aa90d3c00252fadb7">More...</a><br /></td></tr>
<tr class="separator:aad2b7aa7d628257aa90d3c00252fadb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae033afaaacf8beefe1f58ee429c559aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ae033afaaacf8beefe1f58ee429c559aa">CtxsT</a> = std::unordered_set&lt; <a class="el" href="namespaceopt.html#aad2b7aa7d628257aa90d3c00252fadb7">ContexT</a>, boost::hash&lt; <a class="el" href="namespaceopt.html#aad2b7aa7d628257aa90d3c00252fadb7">ContexT</a> &gt; &gt;</td></tr>
<tr class="memdesc:ae033afaaacf8beefe1f58ee429c559aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of contexts that serve as a candidates of a conversion rule.  <a href="#ae033afaaacf8beefe1f58ee429c559aa">More...</a><br /></td></tr>
<tr class="separator:ae033afaaacf8beefe1f58ee429c559aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27cf0ca8a59c842f6736b669ddab492"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ac27cf0ca8a59c842f6736b669ddab492">CandsT</a> = std::unordered_map&lt; <a class="el" href="structopt_1_1_symbol.html">Symbol</a>, <a class="el" href="namespaceopt.html#ae033afaaacf8beefe1f58ee429c559aa">CtxsT</a>, <a class="el" href="structopt_1_1_symbol_hash.html">SymbolHash</a> &gt;</td></tr>
<tr class="memdesc:ac27cf0ca8a59c842f6736b669ddab492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of convers symbols to its potential candidate conversion rules.  <a href="#ac27cf0ca8a59c842f6736b669ddab492">More...</a><br /></td></tr>
<tr class="separator:ac27cf0ca8a59c842f6736b669ddab492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe088a56f57ea4ec30237b5aad94a7c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#abe088a56f57ea4ec30237b5aad94a7c5">CandArgsT</a> = std::vector&lt; <a class="el" href="structopt_1_1_cand_arg.html">CandArg</a> &gt;</td></tr>
<tr class="memdesc:abe088a56f57ea4ec30237b5aad94a7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of candidate arguments.  <a href="#abe088a56f57ea4ec30237b5aad94a7c5">More...</a><br /></td></tr>
<tr class="separator:abe088a56f57ea4ec30237b5aad94a7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9309debb487ca336943cfc15c5e54f11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a9309debb487ca336943cfc15c5e54f11">ConvptrT</a> = std::shared_ptr&lt; <a class="el" href="structopt_1_1i_converter.html">iConverter</a> &gt;</td></tr>
<tr class="memdesc:a9309debb487ca336943cfc15c5e54f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of converter.  <a href="#a9309debb487ca336943cfc15c5e54f11">More...</a><br /></td></tr>
<tr class="separator:a9309debb487ca336943cfc15c5e54f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ffa45c46a2277d45cb2e2c159a7fe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#adf3ffa45c46a2277d45cb2e2c159a7fe">VoterArgsT</a> = std::vector&lt; <a class="el" href="structopt_1_1_voter_arg.html">VoterArg</a> &gt;</td></tr>
<tr class="memdesc:adf3ffa45c46a2277d45cb2e2c159a7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of voter arguments for branching nodes.  <a href="#adf3ffa45c46a2277d45cb2e2c159a7fe">More...</a><br /></td></tr>
<tr class="separator:adf3ffa45c46a2277d45cb2e2c159a7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dab447400162efdad40dad769938d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a16dab447400162efdad40dad769938d4">VotptrT</a> = std::shared_ptr&lt; <a class="el" href="structopt_1_1i_voter.html">iVoter</a> &gt;</td></tr>
<tr class="memdesc:a16dab447400162efdad40dad769938d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer of rule tree.  <a href="#a16dab447400162efdad40dad769938d4">More...</a><br /></td></tr>
<tr class="separator:a16dab447400162efdad40dad769938d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3234fc3997a9e31604fb8ccb51d8efe0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a3234fc3997a9e31604fb8ccb51d8efe0">CstConvertF</a> = std::function&lt; <a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a>(<a class="el" href="structteq_1_1i_tensor.html">teq::iTensor</a> *)&gt;</td></tr>
<tr class="separator:a3234fc3997a9e31604fb8ccb51d8efe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f74ceb7ace7a497919157bafce784b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a49f74ceb7ace7a497919157bafce784b">ImmutablesT</a> = std::vector&lt; <a class="el" href="namespaceteq.html#a6928e6e8dff44ecaf56427804eda6b2f">teq::LeafptrT</a> &gt;</td></tr>
<tr class="memdesc:a49f74ceb7ace7a497919157bafce784b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of presumably immutable leaves.  <a href="#a49f74ceb7ace7a497919157bafce784b">More...</a><br /></td></tr>
<tr class="separator:a49f74ceb7ace7a497919157bafce784b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d94c406773f5f0aeeaefd2a64298972"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a0d94c406773f5f0aeeaefd2a64298972">HFunctorsT</a> = std::vector&lt; std::vector&lt; <a class="el" href="namespaceteq.html#a461b0cef871b09c4e28c4173427cb80a">teq::FuncptrT</a> &gt; &gt;</td></tr>
<tr class="memdesc:a0d94c406773f5f0aeeaefd2a64298972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of functors.  <a href="#a0d94c406773f5f0aeeaefd2a64298972">More...</a><br /></td></tr>
<tr class="separator:a0d94c406773f5f0aeeaefd2a64298972"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6367085ef73bbc00b9eab1bfffda5c75"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a6367085ef73bbc00b9eab1bfffda5c75">CAND_TYPE</a> { <a class="el" href="namespaceopt.html#a6367085ef73bbc00b9eab1bfffda5c75aa5cab2e5396fa71f27366f731881a982">SCALAR</a> = 0, 
<a class="el" href="namespaceopt.html#a6367085ef73bbc00b9eab1bfffda5c75a57a910804e02bfb580e5dd05c7d3aec9">CONST</a>, 
<a class="el" href="namespaceopt.html#a6367085ef73bbc00b9eab1bfffda5c75a2136fec4bc854238c15c965fd2672e78">INTERM</a>, 
<a class="el" href="namespaceopt.html#a6367085ef73bbc00b9eab1bfffda5c75add7ad5cb827b2955c8e47010ddf03be5">CONVRT</a>
 }</td></tr>
<tr class="memdesc:a6367085ef73bbc00b9eab1bfffda5c75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_conversion.html" title="Represent a conversion between two rule trees. ">Conversion</a> type.  <a href="namespaceopt.html#a6367085ef73bbc00b9eab1bfffda5c75">More...</a><br /></td></tr>
<tr class="separator:a6367085ef73bbc00b9eab1bfffda5c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2676a7b37ab954a2a8d469365f2ac28e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a2676a7b37ab954a2a8d469365f2ac28e">operator==</a> (const <a class="el" href="structopt_1_1_symbol.html">Symbol</a> &amp;lhs, const <a class="el" href="structopt_1_1_symbol.html">Symbol</a> &amp;rhs)</td></tr>
<tr class="memdesc:a2676a7b37ab954a2a8d469365f2ac28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare equality of Symbols.  <a href="#a2676a7b37ab954a2a8d469365f2ac28e">More...</a><br /></td></tr>
<tr class="separator:a2676a7b37ab954a2a8d469365f2ac28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82042ef61fa117e6043258fad6d3f3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a82042ef61fa117e6043258fad6d3f3e0">sort_vargs</a> (<a class="el" href="namespaceopt.html#adf3ffa45c46a2277d45cb2e2c159a7fe">VoterArgsT</a> &amp;args)</td></tr>
<tr class="memdesc:a82042ef61fa117e6043258fad6d3f3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize voter arguments to facilitate matching.  <a href="#a82042ef61fa117e6043258fad6d3f3e0">More...</a><br /></td></tr>
<tr class="separator:a82042ef61fa117e6043258fad6d3f3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903b95cff9efd5fc2cab00fa8efe2bee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a903b95cff9efd5fc2cab00fa8efe2bee">operator==</a> (const <a class="el" href="namespaceopt.html#adf3ffa45c46a2277d45cb2e2c159a7fe">VoterArgsT</a> &amp;lhs, const <a class="el" href="namespaceopt.html#adf3ffa45c46a2277d45cb2e2c159a7fe">VoterArgsT</a> &amp;rhs)</td></tr>
<tr class="memdesc:a903b95cff9efd5fc2cab00fa8efe2bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare equality of ordered voter arguments.  <a href="#a903b95cff9efd5fc2cab00fa8efe2bee">More...</a><br /></td></tr>
<tr class="separator:a903b95cff9efd5fc2cab00fa8efe2bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20e01c2870226c38bc5d1bb48e22b1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aa20e01c2870226c38bc5d1bb48e22b1e">operator==</a> (const <a class="el" href="structopt_1_1_seg_v_args.html">SegVArgs</a> &amp;lhs, const <a class="el" href="structopt_1_1_seg_v_args.html">SegVArgs</a> &amp;rhs)</td></tr>
<tr class="memdesc:aa20e01c2870226c38bc5d1bb48e22b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare equality of commutative arguments.  <a href="#aa20e01c2870226c38bc5d1bb48e22b1e">More...</a><br /></td></tr>
<tr class="separator:aa20e01c2870226c38bc5d1bb48e22b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08951494c6c44decbf001e0618a34d3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a08951494c6c44decbf001e0618a34d3a">optimize</a> (<a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> roots, const <a class="el" href="structopt_1_1_opt_ctx.html">OptCtx</a> &amp;opts)</td></tr>
<tr class="separator:a08951494c6c44decbf001e0618a34d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d9be1023f1cc9481f117420fef6e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopt_1_1_opt_ctx.html">OptCtx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ab9d9be1023f1cc9481f117420fef6e5f">parse</a> (std::string content, const <a class="el" href="structopt_1_1i_converter_builder.html">iConverterBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:ab9d9be1023f1cc9481f117420fef6e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all parsed optimization rules of string content.  <a href="#ab9d9be1023f1cc9481f117420fef6e5f">More...</a><br /></td></tr>
<tr class="separator:ab9d9be1023f1cc9481f117420fef6e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc3a35d1f8bdea7ba10cdf2e5f47a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopt_1_1_opt_ctx.html">OptCtx</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#adcc3a35d1f8bdea7ba10cdf2e5f47a4a">parse_file</a> (std::string filename, const <a class="el" href="structopt_1_1i_converter_builder.html">iConverterBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:adcc3a35d1f8bdea7ba10cdf2e5f47a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all parsed optimization rules of a file.  <a href="#adcc3a35d1f8bdea7ba10cdf2e5f47a4a">More...</a><br /></td></tr>
<tr class="separator:adcc3a35d1f8bdea7ba10cdf2e5f47a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3856b6b01fef6c4e6c3e49d00132cf94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a3856b6b01fef6c4e6c3e49d00132cf94">replace_parents</a> (const <a class="el" href="structteq_1_1_parent_finder.html">teq::ParentFinder</a> &amp;pfinder, <a class="el" href="structteq_1_1i_tensor.html">teq::iTensor</a> *source, <a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a> target)</td></tr>
<tr class="separator:a3856b6b01fef6c4e6c3e49d00132cf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6d6cbf4488afe0b314379e679d75d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e6d6cbf4488afe0b314379e679d75d0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a5e6d6cbf4488afe0b314379e679d75d0">remove_duplicates</a> (<a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> &amp;roots, std::vector&lt; T &gt; tens, const <a class="el" href="structteq_1_1_parent_finder.html">teq::ParentFinder</a> &amp;pfinder, <a class="el" href="structtag_1_1_tag_registry.html">tag::TagRegistry</a> &amp;registry=<a class="el" href="namespacetag.html#ad59098e3480c1d395b4b72098a6c0ab7">tag::get_reg</a>())</td></tr>
<tr class="separator:a5e6d6cbf4488afe0b314379e679d75d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb46fdca23d490e6277e3d81a45fc8b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#aeb46fdca23d490e6277e3d81a45fc8b6">populate_graph</a> (<a class="el" href="namespaceopt.html#a49f74ceb7ace7a497919157bafce784b">ImmutablesT</a> &amp;immutables, <a class="el" href="namespaceopt.html#a0d94c406773f5f0aeeaefd2a64298972">HFunctorsT</a> &amp;functors, const <a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> &amp;roots)</td></tr>
<tr class="separator:aeb46fdca23d490e6277e3d81a45fc8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f1f3d7ecea4bfab75146a93d42eec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ac9f1f3d7ecea4bfab75146a93d42eec5">remove_all_duplicates</a> (<a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> &amp;roots, <a class="el" href="namespaceopt.html#a49f74ceb7ace7a497919157bafce784b">ImmutablesT</a> &amp;immutables, <a class="el" href="namespaceopt.html#a0d94c406773f5f0aeeaefd2a64298972">HFunctorsT</a> &amp;functors)</td></tr>
<tr class="separator:ac9f1f3d7ecea4bfab75146a93d42eec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4d2c59659fcdc3b488a0864bec7957"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#abb4d2c59659fcdc3b488a0864bec7957">is_scalar</a> (<a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *leaf)</td></tr>
<tr class="memdesc:abb4d2c59659fcdc3b488a0864bec7957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if leaf contains a scalar.  <a href="#abb4d2c59659fcdc3b488a0864bec7957">More...</a><br /></td></tr>
<tr class="separator:abb4d2c59659fcdc3b488a0864bec7957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af168683f3584aecdbe3c0ecec51354d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#af168683f3584aecdbe3c0ecec51354d0">to_string</a> (<a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a> c)</td></tr>
<tr class="memdesc:af168683f3584aecdbe3c0ecec51354d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return brief hashable string representation of coordinate mapper.  <a href="#af168683f3584aecdbe3c0ecec51354d0">More...</a><br /></td></tr>
<tr class="separator:af168683f3584aecdbe3c0ecec51354d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755a704f3832068e88d7fb4b0356263e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a755a704f3832068e88d7fb4b0356263e">lt</a> (<a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a> a, <a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a> b)</td></tr>
<tr class="memdesc:a755a704f3832068e88d7fb4b0356263e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a &lt; b according to some internal ordinal rule.  <a href="#a755a704f3832068e88d7fb4b0356263e">More...</a><br /></td></tr>
<tr class="separator:a755a704f3832068e88d7fb4b0356263e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da5b49b38d38664404314a5dc934c24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a2da5b49b38d38664404314a5dc934c24">is_equal</a> (<a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a> a, <a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a> b)</td></tr>
<tr class="memdesc:a2da5b49b38d38664404314a5dc934c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a is equal to b.  <a href="#a2da5b49b38d38664404314a5dc934c24">More...</a><br /></td></tr>
<tr class="separator:a2da5b49b38d38664404314a5dc934c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aca88eebd2a18ea99b4118432de85ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a5aca88eebd2a18ea99b4118432de85ae">lt</a> (<a class="el" href="namespaceteq.html#a06d5cc6ba08f690e19ee8cf46d289993">teq::TensSetT</a> priorities, <a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *a, <a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *b)</td></tr>
<tr class="separator:a5aca88eebd2a18ea99b4118432de85ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7628800ab28d331647e8601839fd4d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ac7628800ab28d331647e8601839fd4d1">is_equal</a> (<a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *a, <a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *b)</td></tr>
<tr class="separator:ac7628800ab28d331647e8601839fd4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50d38e3b3e028855d9bb5ee9ff86c88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#ad50d38e3b3e028855d9bb5ee9ff86c88">lt</a> (<a class="el" href="namespaceteq.html#a06d5cc6ba08f690e19ee8cf46d289993">teq::TensSetT</a> priorities, <a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *a, <a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *b)</td></tr>
<tr class="separator:ad50d38e3b3e028855d9bb5ee9ff86c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aca5bb398fe0dae61ffdd3f3829224"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a83aca5bb398fe0dae61ffdd3f3829224">is_equal</a> (<a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *a, <a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *b)</td></tr>
<tr class="separator:a83aca5bb398fe0dae61ffdd3f3829224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a880213957cf570053ec5c49c0fe6556d"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopt.html#a880213957cf570053ec5c49c0fe6556d">group_prefix</a> = &quot;group:&quot;</td></tr>
<tr class="memdesc:a880213957cf570053ec5c49c0fe6556d"><td class="mdescLeft">&#160;</td><td class="mdescRight">String to prefix group types.  <a href="#a880213957cf570053ec5c49c0fe6556d">More...</a><br /></td></tr>
<tr class="separator:a880213957cf570053ec5c49c0fe6556d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="candidate_8hpp.html">candidate.hpp</a> opt</p>
<p>Purpose: Define TEQ graph intermediate representations</p>
<p><a class="el" href="iconverter_8hpp.html">iconverter.hpp</a> opt</p>
<p>Purpose: Define converter interface for building TEQ graphs given candidate IR graph</p>
<p><a class="el" href="ivoter_8hpp.html">ivoter.hpp</a> opt</p>
<p>Purpose: Define rule voter interface to identify graph nodes</p>
<p><a class="el" href="matcher_8hpp.html">matcher.hpp</a> opt</p>
<p>Purpose: Implement matcher traveler for gathering conversion candidates from a TEQ graph</p>
<p><a class="el" href="optimize_8hpp.html">optimize.hpp</a> opt</p>
<p>Purpose: Implement algorithm that applies conversion rules to graph roots</p>
<p>parse.hpp opt</p>
<p>Purpose: Define interfaces to build extensions of TEQ graphs and wrap around C parser</p>
<p><a class="el" href="rmdups_8hpp.html">rmdups.hpp</a> opt</p>
<p>Purpose: Define TEQ functor duplication removal algorithm</p>
<p><a class="el" href="stats_8hpp.html">stats.hpp</a> opt</p>
<p>Purpose: Define comparator and conversion for TEQ objects for OPT normalization and logging</p>
<p><a class="el" href="voter_8hpp.html">voter.hpp</a> opt</p>
<p>Purpose: Implement rule voter to identify functor types </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="abe088a56f57ea4ec30237b5aad94a7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe088a56f57ea4ec30237b5aad94a7c5">&#9670;&nbsp;</a></span>CandArgsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#abe088a56f57ea4ec30237b5aad94a7c5">opt::CandArgsT</a> = typedef std::vector&lt;<a class="el" href="structopt_1_1_cand_arg.html">CandArg</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of candidate arguments. </p>

</div>
</div>
<a id="ac27cf0ca8a59c842f6736b669ddab492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27cf0ca8a59c842f6736b669ddab492">&#9670;&nbsp;</a></span>CandsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#ac27cf0ca8a59c842f6736b669ddab492">opt::CandsT</a> = typedef std::unordered_map&lt;<a class="el" href="structopt_1_1_symbol.html">Symbol</a>,<a class="el" href="namespaceopt.html#ae033afaaacf8beefe1f58ee429c559aa">CtxsT</a>,<a class="el" href="structopt_1_1_symbol_hash.html">SymbolHash</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map of convers symbols to its potential candidate conversion rules. </p>

</div>
</div>
<a id="aad2b7aa7d628257aa90d3c00252fadb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2b7aa7d628257aa90d3c00252fadb7">&#9670;&nbsp;</a></span>ContexT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#aad2b7aa7d628257aa90d3c00252fadb7">opt::ContexT</a> = typedef std::map&lt;std::string,<a class="el" href="namespaceopt.html#a8417f9778df10bf451cc044b720fa8c5">CtxValT</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map of rule graph leaf identifiers to corresponding matches. </p>

</div>
</div>
<a id="a9309debb487ca336943cfc15c5e54f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9309debb487ca336943cfc15c5e54f11">&#9670;&nbsp;</a></span>ConvptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a9309debb487ca336943cfc15c5e54f11">opt::ConvptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structopt_1_1i_converter.html">iConverter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of converter. </p>

</div>
</div>
<a id="a3234fc3997a9e31604fb8ccb51d8efe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3234fc3997a9e31604fb8ccb51d8efe0">&#9670;&nbsp;</a></span>CstConvertF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a3234fc3997a9e31604fb8ccb51d8efe0">opt::CstConvertF</a> = typedef std::function&lt;<a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a>(<a class="el" href="structteq_1_1i_tensor.html">teq::iTensor</a>*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that takes raw tensor pointer and cast to constant tensor If input tensor is not constant return null </p>

</div>
</div>
<a id="ae033afaaacf8beefe1f58ee429c559aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae033afaaacf8beefe1f58ee429c559aa">&#9670;&nbsp;</a></span>CtxsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#ae033afaaacf8beefe1f58ee429c559aa">opt::CtxsT</a> = typedef std::unordered_set&lt;<a class="el" href="namespaceopt.html#aad2b7aa7d628257aa90d3c00252fadb7">ContexT</a>,boost::hash&lt;<a class="el" href="namespaceopt.html#aad2b7aa7d628257aa90d3c00252fadb7">ContexT</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of contexts that serve as a candidates of a conversion rule. </p>

</div>
</div>
<a id="a8417f9778df10bf451cc044b720fa8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8417f9778df10bf451cc044b720fa8c5">&#9670;&nbsp;</a></span>CtxValT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a8417f9778df10bf451cc044b720fa8c5">opt::CtxValT</a> = typedef std::set&lt;<a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of tensors that potentially matches some id. </p>

</div>
</div>
<a id="a0d94c406773f5f0aeeaefd2a64298972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d94c406773f5f0aeeaefd2a64298972">&#9670;&nbsp;</a></span>HFunctorsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a0d94c406773f5f0aeeaefd2a64298972">opt::HFunctorsT</a> = typedef std::vector&lt;std::vector&lt;<a class="el" href="namespaceteq.html#a461b0cef871b09c4e28c4173427cb80a">teq::FuncptrT</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix of functors. </p>

</div>
</div>
<a id="a49f74ceb7ace7a497919157bafce784b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f74ceb7ace7a497919157bafce784b">&#9670;&nbsp;</a></span>ImmutablesT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a49f74ceb7ace7a497919157bafce784b">opt::ImmutablesT</a> = typedef std::vector&lt;<a class="el" href="namespaceteq.html#a6928e6e8dff44ecaf56427804eda6b2f">teq::LeafptrT</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of presumably immutable leaves. </p>

</div>
</div>
<a id="adf3ffa45c46a2277d45cb2e2c159a7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3ffa45c46a2277d45cb2e2c159a7fe">&#9670;&nbsp;</a></span>VoterArgsT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#adf3ffa45c46a2277d45cb2e2c159a7fe">opt::VoterArgsT</a> = typedef std::vector&lt;<a class="el" href="structopt_1_1_voter_arg.html">VoterArg</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of voter arguments for branching nodes. </p>

</div>
</div>
<a id="a16dab447400162efdad40dad769938d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dab447400162efdad40dad769938d4">&#9670;&nbsp;</a></span>VotptrT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopt.html#a16dab447400162efdad40dad769938d4">opt::VotptrT</a> = typedef std::shared_ptr&lt;<a class="el" href="structopt_1_1i_voter.html">iVoter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer of rule tree. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6367085ef73bbc00b9eab1bfffda5c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6367085ef73bbc00b9eab1bfffda5c75">&#9670;&nbsp;</a></span>CAND_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceopt.html#a6367085ef73bbc00b9eab1bfffda5c75">opt::CAND_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_conversion.html" title="Represent a conversion between two rule trees. ">Conversion</a> type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6367085ef73bbc00b9eab1bfffda5c75aa5cab2e5396fa71f27366f731881a982"></a>SCALAR&#160;</td><td class="fielddoc"><p>Convert to a scalar. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6367085ef73bbc00b9eab1bfffda5c75a57a910804e02bfb580e5dd05c7d3aec9"></a>CONST&#160;</td><td class="fielddoc"><p>Convert to a non-scalar constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6367085ef73bbc00b9eab1bfffda5c75a2136fec4bc854238c15c965fd2672e78"></a>INTERM&#160;</td><td class="fielddoc"><p>Intermediate conversion. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6367085ef73bbc00b9eab1bfffda5c75add7ad5cb827b2955c8e47010ddf03be5"></a>CONVRT&#160;</td><td class="fielddoc"><p>Full conversion to a subgraph. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2da5b49b38d38664404314a5dc934c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da5b49b38d38664404314a5dc934c24">&#9670;&nbsp;</a></span>is_equal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::is_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a is equal to b. </p>

</div>
</div>
<a id="ac7628800ab28d331647e8601839fd4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7628800ab28d331647e8601839fd4d1">&#9670;&nbsp;</a></span>is_equal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::is_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if a and b are both tagged immutable and share the same shape and data values </p>

</div>
</div>
<a id="a83aca5bb398fe0dae61ffdd3f3829224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83aca5bb398fe0dae61ffdd3f3829224">&#9670;&nbsp;</a></span>is_equal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::is_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if a and b are the same opcode and have identical function arguments (same children, shapers, and coorders) Argument order matters unless the op is tagged as commutative </p>

</div>
</div>
<a id="abb4d2c59659fcdc3b488a0864bec7957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4d2c59659fcdc3b488a0864bec7957">&#9670;&nbsp;</a></span>is_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::is_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *&#160;</td>
          <td class="paramname"><em>leaf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if leaf contains a scalar. </p>

</div>
</div>
<a id="a755a704f3832068e88d7fb4b0356263e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755a704f3832068e88d7fb4b0356263e">&#9670;&nbsp;</a></span>lt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a &lt; b according to some internal ordinal rule. </p>

</div>
</div>
<a id="a5aca88eebd2a18ea99b4118432de85ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aca88eebd2a18ea99b4118432de85ae">&#9670;&nbsp;</a></span>lt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#a06d5cc6ba08f690e19ee8cf46d289993">teq::TensSetT</a>&#160;</td>
          <td class="paramname"><em>priorities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_leaf.html">teq::iLeaf</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if a.type_code &lt; b.type_code or a.shape &lt; b.shape if all above properties are equal, return true if a is in priorities otherwise false </p>

</div>
</div>
<a id="ad50d38e3b3e028855d9bb5ee9ff86c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50d38e3b3e028855d9bb5ee9ff86c88">&#9670;&nbsp;</a></span>lt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::lt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#a06d5cc6ba08f690e19ee8cf46d289993">teq::TensSetT</a>&#160;</td>
          <td class="paramname"><em>priorities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_functor.html">teq::iFunctor</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if a.opcode &lt; b.opcode or a.shape &lt; b.shape or a.nchildren &lt; b.nchildren if all above properties are equal, return true if a is in priorities otherwise false </p>

</div>
</div>
<a id="a2676a7b37ab954a2a8d469365f2ac28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2676a7b37ab954a2a8d469365f2ac28e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopt_1_1_symbol.html">Symbol</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopt_1_1_symbol.html">Symbol</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare equality of Symbols. </p>

</div>
</div>
<a id="a903b95cff9efd5fc2cab00fa8efe2bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903b95cff9efd5fc2cab00fa8efe2bee">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceopt.html#adf3ffa45c46a2277d45cb2e2c159a7fe">VoterArgsT</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopt.html#adf3ffa45c46a2277d45cb2e2c159a7fe">VoterArgsT</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare equality of ordered voter arguments. </p>

</div>
</div>
<a id="aa20e01c2870226c38bc5d1bb48e22b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20e01c2870226c38bc5d1bb48e22b1e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopt_1_1_seg_v_args.html">SegVArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopt_1_1_seg_v_args.html">SegVArgs</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare equality of commutative arguments. </p>

</div>
</div>
<a id="a08951494c6c44decbf001e0618a34d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08951494c6c44decbf001e0618a34d3a">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> opt::optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a>&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopt_1_1_opt_ctx.html">OptCtx</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return optimized roots where optimization rules are applied to subgraphs Optimized graph roots are moved back to their corresponding root tensors Additionally two or more tensors sharing symbolically identical representations are "joined" (with the exception of tensors in roots set) </p>

</div>
</div>
<a id="ab9d9be1023f1cc9481f117420fef6e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d9be1023f1cc9481f117420fef6e5f">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopt_1_1_opt_ctx.html">OptCtx</a> opt::parse </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopt_1_1i_converter_builder.html">iConverterBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all parsed optimization rules of string content. </p>

</div>
</div>
<a id="adcc3a35d1f8bdea7ba10cdf2e5f47a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc3a35d1f8bdea7ba10cdf2e5f47a4a">&#9670;&nbsp;</a></span>parse_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopt_1_1_opt_ctx.html">OptCtx</a> opt::parse_file </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structopt_1_1i_converter_builder.html">iConverterBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return all parsed optimization rules of a file. </p>

</div>
</div>
<a id="aeb46fdca23d490e6277e3d81a45fc8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb46fdca23d490e6277e3d81a45fc8b6">&#9670;&nbsp;</a></span>populate_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt::populate_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopt.html#a49f74ceb7ace7a497919157bafce784b">ImmutablesT</a> &amp;&#160;</td>
          <td class="paramname"><em>immutables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopt.html#a0d94c406773f5f0aeeaefd2a64298972">HFunctorsT</a> &amp;&#160;</td>
          <td class="paramname"><em>functors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> &amp;&#160;</td>
          <td class="paramname"><em>roots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate immutables with immutable leaves and functors with functors ordered by functor max height in ascending order </p>

</div>
</div>
<a id="ac9f1f3d7ecea4bfab75146a93d42eec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f1f3d7ecea4bfab75146a93d42eec5">&#9670;&nbsp;</a></span>remove_all_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt::remove_all_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopt.html#a49f74ceb7ace7a497919157bafce784b">ImmutablesT</a> &amp;&#160;</td>
          <td class="paramname"><em>immutables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceopt.html#a0d94c406773f5f0aeeaefd2a64298972">HFunctorsT</a> &amp;&#160;</td>
          <td class="paramname"><em>functors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete and update equivalent immutable leaves and functors according to remove_duplicates </p>

</div>
</div>
<a id="a5e6d6cbf4488afe0b314379e679d75d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6d6cbf4488afe0b314379e679d75d0">&#9670;&nbsp;</a></span>remove_duplicates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; opt::remove_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#aedad6309a6ae3cb41f5554dd13bbecfd">teq::TensptrsT</a> &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>tens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structteq_1_1_parent_finder.html">teq::ParentFinder</a> &amp;&#160;</td>
          <td class="paramname"><em>pfinder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag_1_1_tag_registry.html">tag::TagRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em> = <code><a class="el" href="namespacetag.html#ad59098e3480c1d395b4b72098a6c0ab7">tag::get_reg</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return non-duplicate nodes of a HeightMatrix row (tens) If T is a functor, a functor X is duplicate if their any of their child have another parent of the same opcode as X that has identical arguments as X (order matters if X is non-commutative) If T is a leaf, a leaf X is duplicate if the leaf is a constant and there exists another constant that has the same shape and data </p>

</div>
</div>
<a id="a3856b6b01fef6c4e6c3e49d00132cf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3856b6b01fef6c4e6c3e49d00132cf94">&#9670;&nbsp;</a></span>replace_parents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt::replace_parents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structteq_1_1_parent_finder.html">teq::ParentFinder</a> &amp;&#160;</td>
          <td class="paramname"><em>pfinder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structteq_1_1i_tensor.html">teq::iTensor</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#ac6fa10743961a35c5b0f38da4e86e4ae">teq::TensptrT</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace source tensor's position with target's position in the sense that all parents of source (found in pfinder) take on target as the new child in place of source's </p>

</div>
</div>
<a id="a82042ef61fa117e6043258fad6d3f3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82042ef61fa117e6043258fad6d3f3e0">&#9670;&nbsp;</a></span>sort_vargs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void opt::sort_vargs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopt.html#adf3ffa45c46a2277d45cb2e2c159a7fe">VoterArgsT</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize voter arguments to facilitate matching. </p>

</div>
</div>
<a id="af168683f3584aecdbe3c0ecec51354d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af168683f3584aecdbe3c0ecec51354d0">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string opt::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceteq.html#a01f57fd31296c84fa2a64cad8c65be2c">teq::CoordptrT</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return brief hashable string representation of coordinate mapper. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a880213957cf570053ec5c49c0fe6556d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880213957cf570053ec5c49c0fe6556d">&#9670;&nbsp;</a></span>group_prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string opt::group_prefix = &quot;group:&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String to prefix group types. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
